\documentclass[gradu]{tktltiki2018}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{url}

\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx,mathabx}
\usepackage{subfigure,xspace}
%\usepackage[lined,boxed]{algorithm2e}
%\usepackage{algorithmicx}
%\usepackage{algorithm}
\usepackage{algpseudocode}
%\usepackage[pdftex,hidelinks]{hyperref}

\begin{document}
\onehalfspacing


\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}{Algoritmi}
\newtheorem{esim}{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}

\newcommand\range[2]{\ensuremath{\left [ #1 , #2 \right )}\xspace}
\newcommand\orange[2]{\ensuremath{\left ( #1 , #2 \right )}\xspace}
\newcommand\crange[2]{\ensuremath{\left [ #1 , #2 \right ]}\xspace}
\newcommand\set[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand\size[1]{\ensuremath{\left |#1\right |}\xspace}
\newcommand\ceil[1]{\ensuremath{\left\lceil #1\right\rceil}\xspace}
\newcommand\reals{\ensuremath{\mathbb{R}}\xspace}

\newcommand\spt{\ensuremath{\dot{s}}\xspace}
\newcommand\ept{\ensuremath{\dot{t}}\xspace}
\newcommand\fspace{\ensuremath{\mathcal{A}}\xspace}
\newcommand\dirs{\ensuremath{\mathcal{C}}\xspace}

\newcommand\epts{\ensuremath{P}\xspace}
\newcommand\segsize{\ensuremath{m}\xspace}
\newcommand\inter[1]{\ensuremath{\textsc{väli}(#1)}\xspace}
\newcommand\leftc[1]{\ensuremath{\textsc{vasen}(#1)}\xspace}
\newcommand\rightc[1]{\ensuremath{\textsc{oikea}(#1)}\xspace}
\newcommand\reach[1]{\ensuremath{\textsc{valo}(#1)}\xspace}
\newcommand\reachd[2]{\ensuremath{\textsc{valo}_{#2}(#1)}\xspace}
\newcommand\canon[1]{\ensuremath{\bar{\textsc{c}}(#1)}\xspace}
\newcommand\canonp[1]{\ensuremath{\dot{\textsc{c}}(#1)}\xspace}
\newcommand\canont[2]{\ensuremath{\textsc{c}(#1,#2)}\xspace}
\newcommand\canoni[2]{\ensuremath{\textsc{c}_{#2}(#1)}\xspace}
\newcommand\visitp{\ensuremath{\textsc{VieraileVanhempi}}\xspace}
\newcommand\visitc{\ensuremath{\textsc{VieraileKanoninen}}\xspace}

\newcommand\pop[1]{\ensuremath{\textsc{pop}(#1)}\xspace}

\newcommand\y[1]{\ensuremath{{#1}_y}\xspace}
\newcommand\x[1]{\ensuremath{{#1}_x}\xspace}
\newcommand\xrange[1]{\ensuremath{x(#1)}\xspace}
\newcommand\yrange[1]{\ensuremath{y(#1)}\xspace}
\newcommand\xranget[2]{\ensuremath{x(#1)_{#2}}\xspace}
\newcommand\yranget[2]{\ensuremath{y(#1)_{#2}}\xspace}
\newcommand\nbs[1]{\ensuremath{\textsc{naap}{(#1)}}\xspace}
\newcommand\nbsd[2]{\ensuremath{\textsc{naap}_{#2}{(#1)}}\xspace}

\newcommand\decomp[1]{\ensuremath{\textsc{hajo}_{#1}}\xspace}
%\newcommand\decompc[1]{\ensuremath{\textsc{hajo}({#1})}\xspace}
\newcommand\sweep[2]{\ensuremath{\textsc{pyyh}_{#2}{(#1)}}\xspace}
\newcommand\stepof[1]{\ensuremath{\textsc{askel}{(#1)}}\xspace}

\newcommand\rotr[1]{\ensuremath{\top #1}\xspace}
\newcommand\vecof[1]{\ensuremath{\left [#1\right ]}\xspace}
\newcommand\sline[1]{\ensuremath{S_{#1}}\xspace}
\newcommand\intert[2]{\ensuremath{\textsc{väli}_{#1}(#2)}\xspace}
\newcommand\point[1]{\ensuremath{\left ({#1}\right )}\xspace}

\newcommand\cellevt{\ensuremath{\texttt{SoluTapahtuma}}\xspace}
\newcommand\obsevt{\ensuremath{\texttt{EsteTapahtuma}}\xspace}
\newcommand\addrectevt{\ensuremath{\texttt{LisäysTapahtuma}}\xspace}



\title{Algoritmeja minimilinkkipolun ongelmaan}
\author{Mikko Sysikaski}
\date{\today}
\level{Pro gradu -tutkielma}

\department{Tietojenkäsittelytieteen maisteriohjelma}

\maketitle

\numberofpagesinformation{\numberofpages\ sivua + \numberofappendixpages\ liitesivua}

%\classification{\protect{\ \\
%\  General and reference $\rightarrow$ Document types  $\rightarrow$ Surveys and overviews\  \\
%\  Applied computing  $\rightarrow$ Document management and text processing  $\rightarrow$ Document management  $\rightarrow$ Text editing\ }}

\keywords{algoritmit, laskennallinen geometria}

\supervisors{Antti Laaksonen ja Jyrki Kivinen}

%oletus
%\program{Tietojenkäsittelytiede}

%Tietojenkäsittelytieteen maisteriohjelman (2017->) tutkielma
%\program{Tietojenkäsittelytieteen maisteriohjelma} 

%Datatieteen maisteriohjelman (2017->) tutkielma
%\program{Datatieteen maisteriohjelma}

%Kandidaatin tutkielma
%\level{Kandidaattitutkielma}
%Tietojenkäsittelytieteen kandiohjelman (2017->) tutkielma
%\program{Tietojenkäsittelytieteen kandiohjelma}

% Tietojenkäsittelytieteen maisteriohjelman opintosuunnat 2017->
%\additionalinformation{Algoritmien opintosuunnan tutkielma }
%\additionalinformation{Hajautettujen järjestelmien ja tietoliikenteen opintosuunnan tutkielma}
%\additionalinformation{Ohjelmistojärjestelmien opintosuunnan tutkielma}

% Tietojenkäsittelytieteen erikoistumislinjat
%\additionalinformation{Algoritmisen bioinformatiikan erikoistumislinjan tutkielma}
%\additionalinformation{Algoritmien, data-analytiikan ja koneoppimisen erikoistumislinjan tutkielma}
%\additionalinformation{Hajautettujen järjestelmien ja tietoliikenteen erikoistumislinjan tutkielma}
%\additionalinformation{Ohjelmistojärjestelmien erikoistumislinjan tutkielma}

%\level{Seminaari essee}
%\additionalinformation{Seminaarin... essee}

\begin{abstract}
Tutkielman aihe ovat algoritmit minimilinkkipolun etsimiseen.
Minimilinkkipolku on on geometrinen reitinhakuongelma, jossa haettavan reitin on tehtävä mahdollisimman vähän käännöksiä.
Työssä esitellään uusia algoritmeja ongelman eri variantteihin.
\end{abstract}

\mytableofcontents




\section{Johdanto}

Erilaiset reitinhakuongelmat ovat laajasti tutkittu algoritmiikan osa-alue.\cite{survey}
Tyypillinen tehtävä on löytää lyhin polku kahden verkon solmun välillä.
Ongelman geometrisessa versiossa taas pyritään löytämään polku kahden pisteen välillä jatkuvassa avaruudessa, yleensä monikulmioiden rajoittamalla alueella tasossa.
Tyypillinen ongelma on minimoida polun euklidinen pituus, mutta pituus ei ole ainoa mielekäs mitta polun hyvyydelle.
Esimerkiksi robotin voi olla nopeampaa liikkua suoraan kuin kääntyillä, jolloin pitkä mutta yksinkertainen polku on lyhyttä mutkittelevaa reittiä parempi vaihtoehto.

Tässä tutkielmassa keskitymme vähän käännöksiä tekevien polkujen löytämiseen.
Kun polku koostuu äärellisestä määrästä suoria janoja, sen \textit{linkkietäisyys} tarkoittaa janojen määrää.
Kahden pisteen välinen \textit{minimilinkkipolku} tarkoittaa polkua jonka linkkietäisyys on pienen mahdollinen.

Minimilinkkipolun haku on hyvin tutkittu algoritmiongelma.
Perusidealtaa algoritmit ovat yksinkertaisia, ja muistuttavat leveyshakua: etsitään alkupisteestä lähtien ensin etäisyydellä 1 olevat pisteet, sitten etäysyydellä 2, ja niin edelleen, kunnes haluttu loppupiste poluta löytyy.
Algoritmien vaikea osuus on löytää sopivat tietorakenteet, joilla ylläpitää jo löydettyjen tason pisteiden joukkoa ja etsiä tehokkaasti seuraavan linkin päässä olevat pisteet.

Työssä esitellään uusia algoritmeja ongelman 2-~ja 3-ulotteisiin variantteihin.
Minimilinkkiongelmaan esitetään approksimaatioalgoritmi, joka on ensimmäinen tunnettu ratkaisu, joka toimii alle neliöllisessä ajassa\cite{revisited}.
Tämän lisäksi tutkitaan ongelman rajoitettua versiota, jossa haettava polku saa kulkea ainoastaan tiettyihin suuntiin.
Ongelmaan esitetään uusi algoritmi, joka toimii ajassa $O(C^2n\log n)$, kun syötepolygoni sisältää $n$ kärkipistettä ja käytettävissä on $C$ kulkusuuntaa\cite{revisited}.
Lisäksi tutustutaan ongelman 3-ulotteiseen versioon, kun ainoat sallitut suunnat ovat koordinaattiakselien suunnat.
3D~ongelmaan esitetään uusi algoritmi, joka toimii ajassa $O(n^2\log^2n)$, joka on merkittävä parannus aiempaan $O(n^{2.5}\log n)$ ratkaisuun\cite{restricted}.

\subsection{Ongelman kuvaus}

Minimilinkkipolkuongelma on määritetty seuraavasti.
\begin{ong}\label{ong:path}
Syötteenä on annettu alueen \fspace kuvaus sekä pisteet $\spt\in\fspace$ ja $\ept\in\fspace$.
Etsi polku, jonka linkkietäisyys on pienin mahdollinen, pisteestä \spt pisteeseen \ept alueen \fspace sisällä.
\end{ong}

Tyypillisesti lyhimmän polun hakevat algoritmit aloittavat haun alkupisteestä ja tutkivat aluetta kunnes loppupiste saavutetaan.
Tällöin voidaan usein muodostaa tietorakenne, joka löytää tehokkaasti polun alkupisteen \spt ja minkä tahansa muun pisteen välillä.
Siksi lähes samoja algoritmeja voidaan soveltaa myös ongelmaan jossa \ept määritellään vasta myöhemmin.

\begin{ong}\label{ong:map}
Syötteenä on annettu alueen \fspace kuvaus sekä piste $\spt\in\fspace$.
Esikäsittele syöte niin, että on tehokasta hakua polku pisteen \spt ja minkä tahansa annetun pisteen $\ept\in\fspace$ välillä.
\end{ong}

\subsection{Yleiskuva algoritmeista}\label{sec:yleiskuva}

Kaikki tunnetut minimilinkkipolut käyttävät samaa perusideaa:
Halutaan muodostaa minimilinkkipolku pisteestä $A$ pisteeseen $B$.
Merkitään kaikki alkupisteistä $k$ linkillä saavutettavien pisteiden joukkoa \reach{k}.
Määritetään aluksi $\reach{0}=\set{A}$, ja lasketaan iteratiivisesti joukko \reach{k+1} aina joukosta \reach{k}.
Iteraatiota jatketaan, kunnes löytyy $k$ jolle $B\in\reach{k}$.
Iteraatiosta käytetään tyypillisesti nimitystä \emph{vaiheittainen valaistus}, koska joukon \reach{k+1} laskua voidaan visualisoida asettamalla valonlähteet kaikkiin pisteisiin \reach{k}, ja tutkimalla mitkä pisteet tulivat valaistuksi.

Prosessi muistuttaa läheisesti syvyyssuuntaista hakua, mutta oleellisena erona hakua ei tehdä verkossa, vaan jatkuvassa avaruudessa.
Algoritmien epätriviaali osuus onkin valaistun osuuden ylläpito, ja joukon \reach{k+1} tehokas laskenta joukosta \reach{k}.
Valaistun alueen esitystä voidaan helpottaa jakamalla alue aluksi yksinkertaisiin osiin.
Kolmiointi on tällaisesta jaosta tyypillinen esimerkki, ja sitä käytetään monissa geometrisissa algoritmeissa.
Rajoitetun suuntaisten minimilinkkipolkujen tapauksessa alue on kuitenkin kätevämpi jakaa suorakulmioihin tai suunnikkaisiin.
Luvussa~\ref{sec:jako} esitetään algoritmi reintinhakuun sopivaan alueen jakoon.

Rajoitetun suuntaisen minimilinkkipolun laskussa alue \reach{k+1} voidaan laskea tehokkaasti alueesta \reach{k} käyttäen \emph{pyyhkäisyviiva-algoritmeja}.
Ideana on, että tason yli "pyyhkäistään" suoralla viivalla, ja pyyhkäisyn aikana lasketaan kuinka polku voi edetä pyyhkäisyviivan liikesuuntaan.
Tällä menetelmällä saadaan vaikea 2-ulotteinen valaistusongelma muutettua joukoksi helpompia 1-ulotteisia ongelmia.
Pyyhkäisyviiva-algoritmien ideaa käsitellään tarkemmin kappaleessa~\ref{sec:sweep}.

Pyyhkäisyn aikana ylläpidetään tietoa pyyhkäisyviivan suhteesta alueen esteisiin sekä joukkoon \reach{k}.
Näiden tietojen ylläpitäminen edellyttää tehokasta 1-ulotteisten intervallien käsittelyä.
\emph{Segmenttipuu} on monikäyttöinen tietorakenne lukuvälien käsittelyyn, ja se mahdollistaa vaiheittaisen valaistuksen vaatimien operaatioiden tehokkaan toteutuksen.
Segmenttipuita käsitellään luvussa~\ref{sec:segtree}.

Edellä mainitut ideat rajoitetun suuntaisen minimilinkkipolun hakuun voidaan yleistää myös kolmiulotteiseen avaruuteen.
Monet yksityiskohdat ovat monimutkaisempia, mutta perusajatus pysyy samana.
Avaruus jaetaan suorakulmioiden sijaan suorakulmaisiin särmiöihin, ja pyyhkäisyviivan sijaan käytetään pyyhkäisytasoa.
Myös segmenttipuut yleistyvät elegantisti moniulottutteiseksi rakenteeksi.
Näitä osatekijöitä yhdistämällä muodostetaan kolmiulotteisen rektilineaarisen minimilinkkipolkuongelman ratkaiseva algoritmi luvussa~\ref{sec:link3d}.



\section{Segmenttipuu}\label{sec:segtree}

Segmenttipuu on tietorakenne yksiulotteisten lukuvälien joukon käsittelyyn.
Rakenne mahdollistaa laajan joukon erilaisia välioperaatioita logaritmisessa ajassa, kuten esimerkiksi
\begin{itemize}
	\item Uuden välin lisäys ja poisto.
	\item Löydä kaikki välit, jotka leikkaavat annettua kyselyväliä.
	\item Etsi piste joka leikkaa annettua kyselyväliä mutta ei yhtäkään väliä tietorakenteessa.
	\item Muokkaa tietorakenteessa olevia välejä niin, että kaikki annettua väliä koskevat osat poistuvat.
\end{itemize}

Segmenttipuu on hyvin yleiskäyttöinen rakenne, jota voi laajentaa soveltumaan moniin tarpeisiin.
Jokaiseen väliin voidaan tallentaa lisäinformaatiota, kuten lisäysaika puuhun, jolloin puusta voidaan hakea vaikkapa viimeisin lisäytty väli joka leikkaa annettua väliä.
Lisäinformaation tallentaminen puuhun kasvattaa sen muistinkäyttöä ja päivitysoperaatioiden suoritusaikaa vakiokertoimella, joten puun tukemat operaatiot on syytä valita tapauskohtaisesti.
Esitämme ensin rakenteen yleiset ideat, ja tutkimme sitten niiden sovellusta minimilinkkipolun ongelman kohdalla.

Segmenttipuut toteutetaan tyypillisesti \emph{semi-dynaamisena} rakenteena.
Tämä tarkoittaa, että puuta voidaan päivittää tehokkaasti, mutta puun rakenne on määritetty etukäteen.
Semi-dynaamisuus mahdollistaa puun tallentamisen muistiin tehokkaasti taulukkona binäärikeon tapaan, mikä tekee puusta käytännöllisen paitsi asymptoottisten rajojen todistamiseen, myös käytännön toteutuksiin.
Semi-dynaamisuus asettaa käytännön rajoitteen, että kaikkien puuhun tallennettavien välien kärkipisteiden joukko \epts on tunnettava etukäteen.
Suurin osa kysely- ja päivitysoperaatioista toimii ajassa $O(\log \size{\epts})$, ja puun tilavaativuus ja luontiaika ovat $O(\size{\epts})$.

\subsection{Segmenttipuun rakenne}

\begin{figure}
\caption{Segmenttipuussa jokainen solmu vastaa lukuväliä, ja lapsisolmujen välit peittävät tarkalleen vanhemman lukuvälin.}\label{segpuu}
\end{figure}

Segmenttipuu on binääripuu, jonka jokainen solmu $s$ vastaa puoliavointa lukuväliä $\inter{s}$.
Solmun $s$ lapsisolmut $\leftc{s}$ ja $\rightc{s}$ jakavat välin $\inter{s}$ kahteen pienempään osaan: $\inter{s}=\inter{\leftc{s}}\cup\inter{\rightc{s}}$, $\inter{\leftc{s}}\cup\inter{\rightc{s}}=\emptyset$.
Puun juurisolmu vastaa suurinta mahdollista, kaikki muut välit sisältävät lukuväliä, ja lehtisolmut pienimpiä mahdollisia välejä $\range{\epts[i]}{\epts[i+1]}$.
Esimerkki segmenttipuun rakenteesta näkyy kuvassa~\ref{segpuu}.

Semi-dynaamisessa segmenttipuussa rakenne muodostetaan heti puun luontivaiheessa, eikä se riipu puuhun lisätyistä väleistä.
Puu on täysin tasapainoinen binääripuu, joten sen voi tallentaa taulukkoon binäärikeon tapaan: jokaista solmua vastaa taulukon indeksi $i$, ja solmun $i$ lapsisolmut ovat $2i$ ja $2i+1$.
Juurisolmua vastaa indeksi~1.

\subsection{Kanoniset solmut}

Tarkastellaan seuraavaksi mielivaltaistan välien esitystä puussa.
Koska kärkipisteiden joukko on etukäteen rajattu $\epts$, jokainen lisätty väli on muotoa $\range{\epts[i]}{\epts[j]}$ joillekin indekseille $i$ ja $j$.

\begin{figure}
\caption{Lukuvälin kanoniset solmut ovat pienin joukko segmenttipuun solmuja, jotka peittävät välin mutta eivät mitään muuta.}\label{kanon}
\end{figure}

Jokaista tällaista väliä $v$ vastaa joukko puun solmuja, joita kutsutaan $v$:n \emph{kanonisiksi solmuiksi}, $\canon{v}$.
\begin{maar}\label{def:canon}
Välin $v$ kanoniset solmut ovat pienin joukko solmuja, jotka peittävät kokonaan välin $v$, mutta eivät mitään muuta, eli $\bigcup_{s\in\canon{v}}\inter{s}=v$.
\end{maar}

Kanonisten solmujen käsite on määritetty myös \emph{pisteelle} (eli luvulle).
Pisteen $p$ kanoniset solmut ovat kaikki solmut, joihin $p$ koskee, eli $\canonp{p}=\set{s \mid p\in\inter{s}}$.
Kuvassa~\ref{kanon} näkyy esimerkki välin ja pisteen kanonisista solmuista puussa.

Olkoon $\segsize=\size{\epts}$.
Seuraavat kaksi lemmaa auttavat segmenttipuuoperaatioiden suoritusajan määrityksessä.

\begin{lem}\label{kanonlog}Kaikille väleille $v$ pätee $\size{\canon{v}}=O(\log\segsize)$\end{lem}
\begin{proof}
Koska segmenttipuu on tasapainoinen binääripuu, sen syvyys on $\Theta(\log\segsize)$.
Voidaan osoittaa, että $\canon{v}$ sisältää korkeintaan 2 solmua jokaisella syvyydellä, josta seuraa haluttu väittämä.
Tämä nähdään helposti, sillä jos jollakin syvyydellä on 3 solmua, niistä keskimmäinen voidaan korvata solmun vanhemmalla ilman että solmujen virittämä lukuväli muuttuu, eli solmujoukko ei ole minimaalinen joten se ei ole kanoninen solmujoukko.
\end{proof}

\begin{lem}\label{kanonplog}Joukolla $\canon{v}$ on $O(\log\segsize)$ esivanhempaa segmenttipuussa.\end{lem}
\begin{proof}
Edellistä vastaavalla argumentilla voidaan osoittaa, että puun jokaisella tasolla on korkeintaan 2 esivanhempaa, josta seuraa jälleen haluttu väite.
Selvästi jokaiselle solmulle $s$ ja sen esivanhemmalle $p$ pätee $\inter{s}\in\inter{p}$.
Siis jos jollakin puun tasolla on 3 joukon $\canon{v}$ esivanhempaa, niistä keskimmäiselle solmulle $x$.
\end{proof}

Puun kanoniset solmut ja niiden esivanhemmat voidaan iteroida läpi seuraavalla algoritmilla:

\begin{alg}\label{alg:seghaku}
Välin $v$ kanonisen solmujoukon haku segmenttipuussa.
\begin{algorithmic}
\Procedure{EtsiKanoniset}{$s$}
\Comment{Vieraile välin $v$ kanonisissa solmuissa ja niiden esivanhemmissa alipuussa $s$}
	\If{$\inter{s}\subseteq v$}
		\State \visitc($s$)
	\ElsIf{$\inter{s}\cap v\neq\emptyset$}
		\State \visitp($s$)
		\State EtsiKanoniset($\leftc{s}$)
		\State EtsiKanoniset($\rightc{s}$)
	\EndIf
\EndProcedure
\end{algorithmic}
\end{alg}

Algoritmia~\ref{alg:seghaku} voidaan käyttää segmenttipuuoperaatioiden toteuttamiseen määrittelemällä kutsutut funktiot \visitc ja \visitp vastaamaan haluttua operaatiota, kuten välin lisäystä solmuun.
Jos päädytään solmuun joka ei ole kanonisen joukon esivanhempi, rekursio loppuu heti.
Siis algoritmin suoritusaika on verrannollinen kanonisten solmujen ja niiden esivanhempien määrään, joka on lemmojen~\ref{kanonlog} ja~\ref{kanonplog} nojalla $O(\log\segsize)$.

\subsection{Operaatiot puussa}

Pisteen ja välin kanoniset solmut määriteltiin hyvin erilaisella tavalla.
Seuraavaksi nähdään, kuinka nämä kaksi määritelmää toimivat yhdessä, ja sallivat välioperaatioiden helpon toteutuksen.

Määritelmistä nähdään triviaalisti, että jos piste $p$ ei ole välillä $v$, niin $\canonp{p}\cap\canon{v}=\emptyset$. Jos piste on välillä, kanonisilla solmujoukoilla on tasan yksi yhteinen solmu.

\begin{lem}\label{leikkaus1}
Olkoon v väli ja p piste. Jos $p\in v$, niin $\size{\canonp{p}\cap\canon{v}}=1$.\end{lem}
\begin{proof}
Koska $\bigcup_{s\in\canon{v}}\inter{s}=v$ ja $p\in v$, pätee $p\in s$ vähintään yhdelle solmulle $s\in\canon{v}$, jolloin määritelmän mukaan myös $s\in\canonp{p}$.
Siis $\size{\canonp{p}\cap\canon{v}}\ge 1$.

Koska $\canon{v}$ on minimaalinen välin $v$ peittävä joukko, mitkään sen välit eivät leikkaa toisiaan, joten solmuja $s$ joille pätee $p\in\inter{x}$ on korkeintaan 1.
Siis $\size{\canonp{p}\cap\canon{v}}\le 1$.
\end{proof}

Lemman~\ref{leikkaus1} ja algoritmin~\ref{alg:seghaku} avulla on helppo toteuttaa rakenne, joka tukee välien tallennusta, ja mahdollistaa tiettyä pistettä leikkaavien välien etsimisen.
Tallennetaan jokaiseen puun solmuun lista siihen lisätyistä väleistä, ja merkitään lisättävä väli jokaisen kanonisen solmun listaan.
Kyselyvaiheessa käydään läpi kaikki pisteen kanoniset solmut, ja niiden välilistat antavat pistettä leikkaavat välit.

Vastaavasti voidaan vaihtaa pisteiden ja lukuvälien järjestystä, ja luoda rakenne, joka tallentaa pisteitä ja sallii annetulla välillä olevien pisteiden tehokkaan haun.
Uuden pisteen lisäys merkitsee pisteen kaikkiin kanonisten solmujen listoihin, ja välillä olevien pisteiden haku tarkistaa pistelistat kaikista välin kanonisista solmuista.

Jos halutaan sekä lisätä rakenteeseen lukuvälejä, että käyttää välejä kyselyihin, tilanne ei ole yhtä suoraviivainen.
Toisiaan leikkaavat välit välit eivät välttämättä jaa yhteisiä kanonisia solmuja, tai kanonisia solmuja voi olla useita, kuten näkyy kuvassa~\ref{kanonfailkuva}.

\begin{figure}
\caption{Toisiaan leikkaavilla väleillä voi olla 0, 1, tai useampia yhteisiä kanonisia solmuja.}\label{kanonfailkuva}
\end{figure}

Ongelma voidaan ratkaista käyttäen kahta segmenttipuuta.
Toiseen tallennetaan lisätyt välit, ja toiseen niiden alkupisteet.
Seuraava lemma auttaa tämän yhdistelmän analyysissä.

\begin{lem}\label{segleikkaus2}Jos $\range{a}{b}\cap\orange{c}{d}\neq\emptyset$, niin joko $a\in\orange{c}{d}$ tai $c\in\range{a}{b}$, mutta ei molemmat.\end{lem}
\begin{proof}
Tarkastellaan kahta tapausta:
\begin{itemize}
\item Jos $a\le c$: Selvästi $a\notin\orange{c}{d}$, ja $\range{a}{b}\cap\orange{c}{d}\neq\emptyset \Leftrightarrow b>c$, jolloin $c\in\range{a}{b}$.
\item Jos $a>c$: Sevästi $c\notin\range{a}{b}$, ja $\range{a}{b}\cap\orange{c}{d}\neq\emptyset \Leftrightarrow a<d$, jolloin $a\in\orange{c}{d}$.
\end{itemize}
\end{proof}

Ylläpidetään kahta segmenttipuuta:
Puuhun $A$ tallennetaan lukuvälejä ja tehdään kyselyjä pisteillä.
Puuhun $B$ tallennetaan pisteitä ja tehdään kyselyjä väleillä.

Välin $\range{a}{b}$ lisäys muokkaa molempia segmenttipuita:
\begin{enumerate}
\item Lisää väli $\range{a}{b}$ puuhun $A$.
\item Lisää piste $a$ puuhun $B$.
\end{enumerate}

Väliä $\range{c}{d}$ leikkaavien välien haku tehdään molemmissa puissa:
\begin{enumerate}
\item Etsi pistettä $c$ leikkaavat välit puussa $A$.
\item Etsi väliin $\range{c}{d}$ sisältyvät pisteet puussa $B$.
\end{enumerate}

Lemman~\ref{segleikkaus2} nojalla kahteen puuhun tehtävien operaatioiden ansiosta hakuoperaatio löytää jokaisen kyselyväliä leikkaavan välin tasan kerran.

\subsubsection{Välin poisto}\label{sec:lazyseg}

Välin $v$ poisto puusta tarkoittaa, että jokainen puuhun lisätty väli $u$ leikataan muotoon $u\setminus v$, mahdollisesti jakaen väli kahteen osaan.
Operaatio voidaan toteuttaa hakemalla kanoniset solmut algoritmilla~\ref{alg:seghaku}, ja käyttämällä seuraavia määritelmiä operaatioille \visitc ja \visitp.
\begin{alg}\label{alg:segrm}
Poista väli $v$ segmenttipuusta.
\begin{algorithmic}
\Procedure{VieraileVanhempi}{$s$}
	\State Kopioi solmuun $s$ tallennetut välit solmuihin \leftc{s} ja \rightc{s}.
	\State Poista välit solmusta $s$.
\EndProcedure
\Procedure{VieraileKanoninen}{$s$}
	\State Tyhjennä alipuu $s$
\EndProcedure
\end{algorithmic}
\end{alg}

Operaatiossa \visitc tehtävä alipuun tyhjennys edellyttää koko alipuun läpikäyntiä.
Suurimmillaan tämä voi tarkoittaa koko puun läpikäyntiä, eli operaatio toimii ajassa $O(\segsize)$.

Poisto-operaatiota voidaan tehostaa suorittamalla alipuun tyhjennys \emph{laiskasti}.
Segmenttipuun jokaiseen solmuun tallennetaan lisäbitti, joka kertoo, onko tämä alipuu määrä tyhjentää laiskasti.
Tällöin algoritmin~\ref{alg:segrm} alipuuntyhjennys voidaan suorittaa pelkästään merkitsemällä tämä bitti todeksi.
Tämän lisäksi muokataan puun läpikäyntialgoritmia~\ref{alg:seghaku} niin, että jokaiseen solmuun $s$ saavuttaessa tarkistetaan, onko alipuu tyhjennettäväksi.
Jos $s$ on tyhjennettävä, poistetaan kyseiseen solmuun tallennettu sisältö, ja merkitään lasten \leftc{s} ja \rightc{s} alipuut tyhjennettäviksi.

Ratkaisu kasvattaa kaikkien puuoperaatioiden työmäärää vakiokertoimella; jokaisen puun läpikäynnin yhteydessä on tarkistettava mitkä alipuut on merkitty tyhjennettäviksi, ja propagoitava tyhjennysoperaatio lapsiin.
Siis muiden operaatioiden asymptoottinen suoritusaika ei muutu, ja algoritmi~\ref{alg:segrm} toimii ajassa $O(\log\segsize)$.

\subsection{Persistentit segmenttipuut}\label{sec:perseg}


\subsection{Moniulotteiset segmenttipuut}\label{sec:segd}

Segmenttipuu voidaan yleistää kaksi- ja useampiulotteiseksi rakenteeksi varsin suoraviivaisesti.
Kaksiulotteinen segmenttipuu mahdollistaa suorakulmioiden tallentamisen ja tehokkaat aluekyselyt suorakulmion muotoiselle alueelle.
Vastaavasti $u$-ulotteinen segmenttipuu mahdollistaa kyselyt $u$-ulotteisessa suorakulmaisessa särmissö, eli lyhyemmin $u$-särmiössä.

Moniulotteinen segmenttipuu koostuu sisäkkäisistä 1-ulotteisista segmenttipuista.
$u$-ulotteisen puun rakenne on tavallinen segmenttipuu, jonka jokaiseen solmuun on tallennettu $u-1$-ulotteinen segmenttipuu.

Jokainen puun dimensio vastaa yhtä puuhun tallennettavien särmiöiden koordinaattiakseleista.
Esimerkiksi 2-ulotteisessa puussa uloin segmenttipuu vastaa $y$-koordinaatteja, ja jokainen solmuihin tallennetuista sisemmistä puista vastaa $x$-koordinaatteja.
Puun lehtisolmut ovat tällöin $u$-särmiöitä, joiden $y$-sivun määrää lehden paikka ulommassa puussa, ja $y$-sivun määrittää paikka sisemmässä puussa.

Kanoniset solmujoukot määritellään vastaavasti kuin yksiulotteisessa puussa.
Määritelmää~\ref{def:canon} mukaillen määrittelemme:
\begin{maar}\label{def:canond}
$u$-särmiön $s$ kanoniset solmut ovat pienin joukko solmuja, jotka peittävät kokonaan särmiön $s$, mutta eivät mitään muuta, eli $\bigcup_{s\in\canon{v}}\inter{s}=v$.
\end{maar}

$u$-särmiön $s$ kanonista joukkoa merkitään samoin kuin yksiulotteisessa tapauksessakin, $\canon{s}$.
Merkitään $u$-särmiön $s$ akselin $k$ suuntaista väliä $s_k$, ja sen kanonista joukkoa 1-ulotteisessa puussa $\canoni{s_k}{k}$.
Kanoninen joukko voidaan määrittää ulottuvuus kerrallaan, mitä valaisee seuraava lemma.

\begin{lem}$u$-ulotteiselle suorakaiteelle $s$ pätee
$$\canon{s}=\set{c_1\times c_2\times c_3\dots \mid c_1\in\canoni{s_1}{1}, c_2\in\canoni{s_2}{2}\dots}$$
eli \canon{s} on yksiulotteisten kanonisten joukkojen karteeninen tulo
$$\canon{s}=\bigtimes_{i=1}^u \canoni{s_i}{i}.$$
%$$\size{\canon{s}}=O(\prod_{i=1}^u \log\size{\epts_i}).$$
\end{lem}
\begin{proof}HT\end{proof}

Yksiulotteisen segmenttipuun ideoita käytettyjen voidaan muodostaa $u$-ulotteinen tietorakenne, joka tukee seuraavia operaatioita:
\begin{itemize}
\item $u$-särmiön lisäys.
\item $u$-särmiön tyhjennys.
\item Tarkistus, koskettaako annettu $u$-särmiö mitään tietorakenteen särmiöistä.
\end{itemize}



\section{Avaruuden jako}\label{sec:jako}

Minimilinkkipolkuongelmassa reittiä etsitään monimutkaisen muotoisella alueella, jossa on pienempiä monikulmioita esteinä.
Syöte on lista monikulmioita, ja kukin monikulmio esitetään listana kärkipisteitä.
Tämä muoto soveltuu heikosti reitin hakuun, sillä estilistasta on hidasta tarkistaa esimerkiksi voiko annetusta lähtepisteestä liikkua haluttuun suuntaan.

Reitinhaun tehostamiseksi vapaa alue voidaan esittää toisessa muodossa, kuten kolmioituna.
Rajoitetun suuntaisten minimilinkkipolkujen haussa kätevä esitysmuoto on jakaa vapaa alue suorakaiteisiin.
Jotta hajotelmaa voidaan käyttää hakualgoritmien toteuttamiseen, tallennettan jokaisen suorakaiteen yhteyteen linkit jokaisessa suunnassa olevaan kyseistä suorakaidetta koskettaviin naapurisuorakaiteisiin.
Toisin sanottuna rakenne on suuntaamaton verkko, jonka jokainen solmu on suorakaide, ja jokaisen toisiaan koskettavan suorakaideparin välillä on kaari.
Jos syötteen estemonikulmioissa on yhteensä $n$ kärkipistettä, voidaan vapaa tila esittää $O(n)$ monikulmiona niin, että naapurilinkkejä on yhteensä $O(n)$.

Vastaavaa rakennetta voidaan käyttää myös 3-ulotteisen minimilinkkipolun haussa.
3-ulotteisessa rektilineaarisessa tapauksessa vapaata aluetta määrittävät monitahokkaat, joiden sivut ovat koordinaattiakselien suuntaiset, ja joilla on yhteensä $n$ kärkipistettä.
Tällöin vapaa alue voidaan esittää suorakulmaisten särmiöiden verkkona, jossa on $O(n^2)$ kaarta.

\subsection{Pyyhkäisyviiva-algoritmit}\label{sec:sweep}

\subsection{Tason jakoalgoritmi}\label{sec:jako2d}

Rektilineaarinen alue voidaan jakaa suorakaiteisiin jatkamalla jokaista vaakasuoraa janaa molempiin suuntiin kunnes ne törmäävät pystysuoraan esteeseen.
Näin muodostunutta rakennetta kutsutaan alueen \emph{vaakasuoraksi hajotelmaksi} \decomp{x}.
Vastaavasti jatkamalla pystysuoria janoja kunnes ne törmäävät vaakasuoraan esteeseen saadaan alueen \emph{pystysuora hajotelma} \decomp{y}.
Tämän rakenteen koko on $O(n)$, sillä jokainen jatkettu jana koskettaa korkeintaan 3:a suorakaidetta.
Jokaisella suorakaiteella on korkeintaan 2 naapuria yläpuolella ja 2 alapuolella.

\decomp{x} voidaan muodostaa pyyhkäisyviiva-algoritmilla.
Alueen yli pyyhkäistään vaakasuoralla viivalla, joka liikkuu alhaalta ylös.
Pyyhkäisyn aikana pidetään yllä pyyhkäisyviivan ja vapaan alueen leikkausta.
Leikkaus koostuu erillisistä lukuväleistä, jotka tallennetaan binäärihakupuuhun välien alkupisteen mukaan järjestettynä.

Jokainen binäärihakupuuhun lisättävä elementti on rakenteilla oleva suorakaide $a$, jolla on seuraavat kentät:
\begin{itemize}
\item Väli $\xrange{a}=\range{\xranget{a}{1}}{\xranget{a}{2}}$.
\item Väli $\yrange{a}=\range{\yranget{a}{1}}{\yranget{a}{2}}$.
\item Lista naapurilinkkejä $\nbs{a}$.
\end{itemize}

Pyyhkäisy pysähtyy jokaisen estesuorakulmion vaakasuoran rajaviivan kohdalla.
Jokainen rajaviiva joko aloittaa tai lopettaa esteen pyyhkäisyn liikutussuuntaan nähden.
Jos viiva aloittaa esteen, niin viivan kohdalle tultaessa sen x-suuntainen väli sisältyy kokonaan hakupuuhun, eli sitä koskettaa puussa tasan 1 väli.
Jos viiva lopettaa esteen, sen vasen tai oikea reuna saattavat koskettaa puussa olevia välejä, eli sitä koskettavia välejä puussa on 0-2.
Kummassakin tapauksessa esteviivaa koskettavat välit poistetaan puusta, ja lisätään mahdollisesti tilalle vakiomäärä uusia välejä, ja lisätään linkit vanhojen ja uusien elementtien välille.
Algoritmin tarkempi kuvaus on seuraava.

\begin{alg}\label{alg:jako2d}
Tason vapaan tilan jako suorakaiteiden joukoksi \decomp{x}.
\begin{algorithmic}
\State $T\gets \text{tyhjä binäärihakupuu}$
\State $E\gets\text{Esteiden vaakasuorat janat}$
\State Järjestä $E$ y-koordinaatin mukaan kasvavaan järjestykseen.
\ForAll{$e\in E$}
	\If{$e$ aloittaa esteen}
		\Comment Tasan 1 väli $T$:ssä koskettaa väliä \xrange{e}
		\State $v\gets\text{Väliä \xrange{e} koskettava väli puussa $T$}$
		\State $\yranget{v}{2}\gets\y{e}$
		\State Poista väli $v$ puusta $T$
		\ForAll{$u\gets v\setminus s$}
			\State $\yranget{u}{1}\gets\y{e}$
			\State Lisää $v$ listaan $\nbs{u}$
			\State $a\gets\text{Uusi suorakaide}$
			\State $\xrange{a}\gets u$
			\State $\yranget{a}{1}\gets\y{e}$
			\State Lisää $a$ puuhun $T$
		\EndFor
	\Else\Comment $s$ aloittaa vapaan tilan
		\State $a\gets\text{Uusi suorakaide}$
		\State $\xrange{a}\gets\xrange{e}$
		\State $\yranget{a}{1}\gets\y{e}$
		\ForAll{$v\in $ väliä \xrange{e} koskettavat välit puussa $T$}
			\State Lisää $v$ listaan \nbs{a}
			\State $\xrange{a}\gets\xrange{a}\cup\xrange{v}$
			\State Poista $v$ puusta $T$
		\EndFor
		\State Lisää $a$ puuhun $T$.
	\EndIf
\EndFor
\end{algorithmic}
\end{alg}

Algoritmin~\ref{alg:jako2d} perusteella voimme todeta seuraavan.

\begin{lem}2D-alue voidaan ajassa $O(n\log n)$ jakaa $O(n)$ suorakulmioon niin, että vierekkäisiä suorakulmiopareja on $O(n)$.\end{lem}
\begin{proof}
Algoritmi~\ref{alg:jako2d} järjestää esteiden vaakasuorat janat y-koordinaatin mukaan ajassa $O(n\log n)$, ja käy ne sitten läpi $O(n)$ askeleessa.

Jokaisella askeleella tulotetaan $O(1)$ suorakaidetta ja yhteyttä niiden välille, sekä tehdään $O(1)$ operaatiota binääripuuhun.
Binääripuu pidetään tasapainotettuna, joten jokainen operaatio siihen voidaan suorittaa ajassa $O(\log n)$.
Siis tulotettavan suorakaideverkon koko on $O(n)$ solmua ja kaarta, ja se rakennetaan ajassa $O(n\log n)$.
\end{proof}

Lisäksi voidaan todeta seuraava tulos, joka helpottaa jakoa käyttävien algoritmien analyysiä.

\begin{lem}\label{lem:jako2do1}Algoritmin~\ref{alg:jako2d} tuottamalle jokaiselle suorakaiteelle $h$ pätee $\size{\nbs{h}}=O(1)$.\end{lem}
\begin{proof}triv\end{proof}


\subsection{3D-hajotelma suorakulmaisiin särmiöihin}\label{sec:jako3d}

Vastaavasti kuin taso jaettiin suorakaiteisiin, voidaan 3-ulotteinen suorakulmaisten monitahokkaiden rajaama alua voidaan jakaa suorakulmaisiin särmiöihin.
Tätä hajotelmaa hyödynnetään 3D-minimilinkkipolun laskussa luvussa~\ref{sec:link3d}.
Polunhakualgoritmin suoritusaika riippuu vahvasti hajotelman koosta, joten on toivottavaa löytää mahdollisimman pieni hajotelma.

Aluetta rajaavat monitahokkaat on määritetty syötteessä listaamalla jokaisen monikulmion kaikkien tahkojen kärkipisteet.
Syötteen koko on kärkipisteiden kokonaismäärä $n$.

Edellä esitetyn 2D-hajotelman ideat voidaan yleistää toimimaan myös 3:ssa ulottuvuudessa.
Tämä ratkaisu tuottaa $O(n^2)$ solmua ja $O(n^2)$ linkkiä niiden välille.
Tunnetaan myös tapoja jakaa 3D-alue pienempään määrään suorakaiteita, mutta näissä hajotelmissa solmujen välinen vierusverkko voi sisältää ylineliöllisen määrän linkkejä.

Hajotelman idea on pyyhkäistä alueen läpi tasolla joka on kohtisuorassa $z$-akselia kohti, ja tarkastella tason ja esteiden leikkausta pyyhkäisyn aikana.
Alueen ja tason leikkausta kutsutaan alueen \emph{poikkileikkaukseksi}.
Idea on muodostaa 2D-hajotelma jokaisessa uniikissa poikkileikkauksessa, ja venyttää näin saatuja $xy$-tason suorakaiteita $z$-akselin suunnassa jotta ne peittävät koko 3-ulotteisen alueen.

\begin{algorithmic}\label{alg:jako3d}
\State $L \gets \text{tyhjä lista}$
\ForAll{Este-suorakaide $t$ kohtisuorassa $z$-akselia vastaan}
	\If $t$ aloittaa esteen
	\Else
	\EndIf
	\State Muodosta 2D-hajotelma alueella $L$.
\EndFor
\end{algorithmic}



\section{Rajoitetun suuntaiset minimilinkkipolut tasossa}\label{sec:limited2d}

Tarkastellaan minimilinkkipolun hakua rajoitteella, että polku saa käyttää vain tietyn suuntaisia linkkejä.
Lisäksi myös esteiden reunat ovat rajoitettu kulkusuuntien mukaisesti.
Luvussa~\ref{subsec:rect2d} tutustutaan rektilineaariseen tapaukseen, jossa kulkusuunnat vastaavat koordinaattiakselien suuntia.
Rektilineaarisen ongelman ratkaisun pohjalta kehitetään luvussa~\ref{subsec:c2d} ratkaisu tapaukseen, jossa mahdollisten kulkusuuntien joukko $C$ on määritetty osana syötettä.

\subsection{Rektilineaariset minimilinkkipolut}\label{subsec:rect2d}

Tarkastellaan aluksi minimilinkkipolun ongelman \emph{rektilineaarista} versiosta.
Tässä versiossa sekä hakualueen monikulmiot että tuotettava reitti on rajattu koostumaan koordinaattiakselien suuntaisista janoista.
Esitämme ongelmaan $O(n \log n)$ ajassa toimivan ratkaisun, jonka ideat toimivat pohjana monimutkaisempien tapausten ratkaisuissa.

\subsubsection{Leikkausverkko}

Reitinhaku etenee kappaleessa~\ref{sec:yleiskuva} esitetyn vaiheittaisen valaistuksen mukaisesti.
Siis aluksi määritetään \reach{0} vastaamaan alupistettä, ja iteratiivisesti lasketaan \reach{k+1} joukon \reach{k} perusteella.
Prosessia jatketaan kunnes haettu loppupiste löytyy.

On helppo nähdä, että missä tahansa minimilinkkipolussa joka toinen linkki on pystysuuntainen, ja joka toinen vaakasuuntainen.
Jaetaan ongelma kahteen osaan, riippuen onko ensimmäinen linkki pysty- vai vaakasuuntainen.
Lyhin polku voidaan löytää ratkaisemalla molemmat osaongelmat, ja valitsemalla löydetyistä poluista lyhyempi.

Tarkastellaan tapausta, jossa ensimmäinen linkki on vaakasuuntainen.
Jos $k$ on parillinen, minkä tahansa minimilinkkipolun linkki $k$ (0-indeksoituna) on vaakasuuntainen, joten \reach{k+1} muodostuu pisteistä, joihin joukosta \reach{k} pääsee liikkumalla vaakasuunnassa.
Vastaavasti parittomalla $k$ voidaan joukko \reach{k+1} muodostaa liikkumalla pystysuunnassa lähtien joukosta \reach{k}.
Näin valaistut alueet liittyvät läheisesti luvussa~\ref{sec:jako2d} esitettyyn alueen vakasuoraan ja pystysuoraan hajotelmaan, mitä havainnollistaa seuraava lemma.

\begin{lem}\label{lem:valaisu}
Jos $k>0$ on parillinen, alue \reach{k+1} muodostuu tasan niistä joukon \decomp{x} suorakaiteista $h$, joille pätee $h\cap\reach{k}\neq\emptyset$.
Jos $k>0$ on pariton, pätee vastaava väite hajotelmalle \decomp{y}.
\end{lem}
\begin{proof}
Joukko \reach{k} on muodostettu valaisemalla joukko \reach{k-1} pystysuunnassa, eli jos $p\in\reach{k}$, niin myös jokainen $q\in\reach{k}$ jolle pätee $q_x=p_x$ ja pisteiden $q$ ja $p$ välillä ei ole estettä.
Siis jos $p\in h\cap\reach{k}$ jollekin $h\in\decomp{x}$, koko pystysuora jana pisteen $p$ läpi suorakaiteen $h$ sisällä on joukossa \reach{k}.
\reach{k+1} muodostetaan valaisemalla vaakasuunnassa joukosta \reach{k}, joten suorakaiteen $h$ lävistävä pystysuora jana valaisee koko suorakaiteen, eli $h\subseteq\reach{k+1}$.

Jokaisen suorakaiteen $h\in\decomp{x}$ vasen ja oikea reuna sisältyvät esteen reunaan, joten jos $h\cap\reach{k}=\emptyset$, niin alueelta \reach{k} ei voida vaakasuunnassa siirtymällä päätyä suorakaiteeseen $h$.
Siis $h\cap\reach{k+1}\emptyset$.

Jos $k$ on pariton, joukko \reach{k} on muodostettu valaisemalla joukko \reach{k-1} vaakasuunnassa, ja vastaava todistus pätee joukolle \decomp{y}.
\end{proof}

Geometristen kappaleiden joukon \emph{leikkausverkko} tarkoittaa verkkoa, jonka solmuja ovat kappaleet, ja solmujen välillä on kaari, jos vastaavien kappaleiden leikkaus on epätyhjä.
Tarkastellaan joukon $\decomp{x}\cup\decomp{y}$ leikkausverkkoa.
Tämän verkon solmuja ovat suorakaiteet, ja toisiaan leikkaavat joukon \decomp{x} ja \decomp{y} suorakaiteet on yhdistetty kaarella.
Lemman~\ref{lem:valaisu} perusteella jos suorakaiteelle $h\in\decomp{x}$ pätee $h\subseteq\reach{2k}$, niin kaikille solmun $h$ naapureille $n$ leikkausverkossa pätee $n\subseteq\reach{2k+1}$.
Siis vaiheittainen valaistus löytää suorakaiteet tasan samassa järjestyksessä kuin leveyssuuntainen haku leikkausverkossa.

Rektilineaarinen minimilinkkipolun ongelma voidaan siis ratkaista muodostamalla leikkausverkko, ja etsimällä siinä lyhin polku alku- ja loppupisteen sisältävien suorakaiteiden välillä leveyshakua käyttäen.
Leikkausverkko on kuitenkin neliöllisen kokoinen, eli sen eksplisiittisesti muodostava algoritmi ei voi toimia alle neliöllisessä ajassa.
Varsinainen haaste onkin leveyshaun tehokas toteuttaminen leikkausverkossa muodostamatta itse verkkoa eksplisiittisesti.

\subsubsection{Leveyshaku leikkausverkossa}

Tarkastellaan jälleen tapausta, jossa polun ensimmäinen linkki on vaakasuuntainen.
Muodostetaan aluksi vaakasuuntainen hajotelma algoritmilla~\ref{alg:jako2d}.
Pystysuuntaista hajotelmaa ei ole tarvetta muodostaa eksplisiittisesti, vaan sen ja vaakasuuntaisen hajotelman leikkausverkkoa käytetään ainoastaan implisiittisenä rakenteena.

\reach{0} on alkupisteestä muodostuva alue $\set{\spt}$, ja \reach{1} pistettä vävistävä vaakasuora suorakaide.
Reitinhaku toimii toistamalla vuorotellen kahta vaihetta:

\begin{enumerate}
\item Kun $k$ on pariton, \reach{k} esitetään joukkona suorakaiteita $H_k\subseteq\decomp{x}$. Jokaisesta suorakaiteesta $h\in H_k$ tutkitaan mitkä uudet suorakaiteet ovat näkyvissä pystysuorassa suunnassa $h$:sta lähtien, ja saadaan näin uusi joukko $\hat{H}_{k+1}=\set{h \mid h\in\decomp{x}, h\cap\reach{k+1}\neq\emptyset}$.
\item Kun $k$ on parillinen, voidaan lemman~\ref{lem:valaisu} perusteella triviaalisti muodostaa $H_{k+1}=\hat{H}_k$, jolloin $\reach{k+1}=\bigcup_{h\in H_{k+1}}h$.
\end{enumerate}

Näitä vaiheita toistetaan kunnes piste~\ept saavutetaan jommassakummassa vaiheessa.

Algoritmin suorituskyvyn kannalta on myös oleellista välttää tutkimasta useaan kertaan samoja alueita.
Koska jokainen aluetta \reach{k} koskettava suorakaide $h$ sisältyy kokonaan joukkoon \reach{k+1}, kuuluu jokainen $h$:sta näkyvä piste joukkoon \reach{k+2}.
Jos suorakaiteen osa valaisteen algoritmin askeleella $k$, niin askeleeta $k+2$ lähtien sitä voidaan käsitellä kuin estettä, sillä kaikki sen läpi kulkevat lyhimmät polut on jo löydetty.

Tarkastellaan pystysuoraa valaisuoperaatiota lähtien suorakaiteiden joukosta $H\subseteq\decomp{x}$.
Uusi valaistu alue haetaan kahden pyyhkäisyn avulla, suuntiin $+y$ ja $-y$.
Merkitään alueesta $A$ suuntaan $s$ suoritettavan pyyhkäisyn tulosta \sweep{A}{s}.
Tarkemmin
\begin{equation}\label{eq:sweep}
\sweep{A}{s}=\set{p+\alpha s \mid p\in A, \alpha\ge 0, p+\beta s\in\fspace \text{ kaikille } \beta\in\crange{0}{\alpha}}.
\end{equation}
Selvästi $\reach{k+1}=\sweep{\reach{k}}{+y}\cup\sweep{\reach{k}}{-y}$ kun $k$ on pariton.

Pyyhkäisyn aikana ylläpidetään tietoa pyyhkäisyviivan sekä uuden valaistavan alueen \reach{k+1} poikkileikkauksesta.
Poikkileikkaus muodostuu toisiaan leikkaamattomista yksiulotteisesta lukuväleistä.
Tietoa säilytetään tasapainotetussa binääripuussa, joka on järjestetty lukuvälien vasemman kärkipisteen mukaan.
Jokainen puuhun tallennettu väli $v$ sisältää seuraavat kentät:
\begin{itemize}
\item HT
\end{itemize}

Pyyhkäisyalgoritmi pysähtyy joukon $H$ sekä jokaisen uuden valaistun suorakaiteiden kohdalla.
Suorakaiteita säilytetään prioriteettijonossa, joka on järjestetty suorakaiteiden alimman pisteen (eli sen joka pyyhkäisyviiva saavuttaa ensimmäisenä) mukaan.

\begin{alg}\label{alg:light2d}
Laske $\sweep{\bigcup_{h\in H}h}{+y}$.
\begin{algorithmic}
\State $Q\gets\text{Joukon $H$ sisältävä prioriteettijono}$.
\State $T\gets\text{Tyhjä binäärihakupuu}$.
\While{$Q$ ei ole tyhjä}
	\State $h\gets\pop{q}$
	\If{$h\in H$}
		\State Lisää \xrange{h} puuhun $T$.
	\EndIf
	\State $r\gets\xrange{h}$
	\ForAll{$n\in\nbsd{h}{+y}$}
		\State $r\gets r\setminus\xrange{n}$
		\If{$\xrange{n}\cap T\neq\emptyset$}
			\If{$n\notin Q$}
				\State Lisää $n$ jonoon $Q$.
			\EndIf
		\EndIf
	\EndFor
	\State Poista väli $r$ puusta $T$.
\EndWhile
\end{algorithmic}
\end{alg}

\begin{lem}\label{lem:light2dtime}Algoritmi~\ref{alg:light2d} toimii ajassa $O(m\log m)$, missä $m$ on löydettyjen suorakaiteiden määrä.\end{lem}
\begin{proof}
Pääsilmukan jokaisella iteraatiolla käsitellään löydetty suorakaide, joten silmukkaa suoritetaan tasan $m$ iteraatiota.
Lemman~\ref{lem:jako2do1} perusteella $\size{\nbs{h}=O(1)}$, joten algoritmin sisempää silmukkaa suoritetaan $O(1)$ iteraatiota.
Siis jokaisella iteraatiolla tehdään $O(1)$ operaatiota prioriteettijonoon $Q$ sekä binäärihakupuuhun $T$.
Jokainen näistä operaatioista voidaan suorittaa ajassa $O(\log m)$, joten algoritmin suoritusaika on $O(m\log m)$.
\end{proof}

\begin{alg}\label{alg:minlink2d}
Laske minimilinkkipolku pisteestä \spt pisteeseen \ept alueen \fspace sisällä.
\begin{algorithmic}
\State Muodosta \decomp{x} alueesta \fspace.
\State $H\gets\set{h\in\decomp{x} \mid \spt\in h}$
\State $k\gets 0$
\While{$H\neq\emptyset$}
	\If{$\ept\in H$}
		\State Lopeta haku.
	\EndIf
	\ForAll{$h\in H$}
		\If{$\stepof{h}$ ei määritelty}
			\State $\stepof{h}\gets k$
		\ElsIf{$\stepof{h} \le k+2$}
			\ForAll{$n\in\nbs{h}$}
				\State Poista $h$ listasta \nbs{n}.
			\EndFor
			\State Poista $h$ joukosta $H$.
		\EndIf
	\EndFor
	\State $H_{+y}\gets\sweep{H}{+y}$
	\State $H_{-y}\gets\sweep{H}{-y}$
	\State $H\gets H_{+y}\cup H_{-y}$
	\State $k\gets k+1$
\EndWhile
\If{$\ept\notin H$}
	\State Alue \fspace ei ole yhtenäinen. \spt ja \ept kuuluvat sen eri osiin.
\EndIf
\end{algorithmic}
\end{alg}

\begin{lau}Algoritmi~\ref{alg:minlink2d} toimii ajassa $O(n\log n)$.\end{lau}
\begin{proof}HT\end{proof}

\begin{lau}Algoritmi~\ref{alg:minlink2d} toimii tilassa $O(n)$.\end{lau}
\begin{proof}triv\end{proof}

\subsection{$C$-suuntaiset minimilinkkipolut}\label{subsec:c2d}

Tarkastellaan seuraavaksi rektilineaarisen minimilinkkipolun ongelman yleistystä.
Rektilineaarisessa ongelmassa sekä aluetta \fspace rajaavat esteet, että tulostettava polku koostuvat koordinaattiakselien suuntaisista janoista.
$C$-suuntaisessa minimilinkkipolun ongelmassa määritetään syötteessä joukko suuntia $C$, ja sekä esteiden reunat että haettavan polun linkit ovat kaikki $C$:n suuntaisia.
Esitämme ongelmaan ajassa $O(\size{C}^2n\log n)$ ja tilassa $O(\size{C}n)$ toimivan algoritmin, joka perustuu edellä esitetyn rektilineaarisen algoritmin ideoihin.

\subsubsection{Alueen jako puolisuunnikkaisiin}

Yleistetään aluksi kappaleessa~\ref{sec:jako} esitetty avaruuden jakomenetelmä toimimaan $C$-suuntaisella alueella.
Hajotelmat \decomp{x} ja \decomp{y} määritettiin jatkamalla $x$- ja $y$-suuntaisia esteiden reunoja kunnes ne törmäävät toisiin esteisiin.
Vastaavasti jokaiselle suunnalle $c\in C$ voidaan määrittää hajotelma \decomp{c} piirtämällä mahdollisimman pitkä $c$-suuntainen jana jokaisen alueen \fspace kärkipisteen läpi.

Merkitään suuntaan $c$ osoittavaa yksikkövektoria $\vec{c}$.
Lisäksi merkitään \rotr{\vec{c}} vektorin $\vec{c}$ pyöritystä $90\degree$ vastapäivään, eli $\rotr{\vecof{x,y}}=\vecof{-y,x}$.

Tarkastellaan jaon \decomp{c} muodostusta.
Yksinkertaisuuden vuoksi oletetaan vektorin $\vec{c}$ osoittavan positiivisen $x$-akselin suuntaan, eli $\vec{c}=\point{1,0}$.
Syöte voidaan muuntaa tähän koordinaatistoon korvaamalla jokainen kärkipiste $\vec{p}$ pisteellä $\point{p\cdot\vec{c},p\cdot\rotr{\vec{c}}}$.

Jako \decomp{c} voidaan muodostaa algoritmia~\ref{alg:jako2d} muistuttavalla menetelmällä.
Pyyhkäistään alueen \fspace yli vaakasuuntaisella (eli $c$-suuntaisella) suoralla.
Pyyhkäisy pysähtyy alueen \fspace jokaisen kärkipisteen $y$-koordinaatin kohdalla, ja pyyhkäisyviivan ja alueen \fspace leikkaukset ovat \decomp{c}:n puolisuunnikkaiden kantoja.

Rektilineaarisesta tapauksesta poiketen alueen \fspace ja pyyhkäisyviivan leikkaus ei pysy vakiona pysähdyspisteiden välillä, vaan muuttuu jatkuvasti.
Leikkaus koostuu yksiulotteisista lukuväleistä, joiden päätepisteet liikkuvat vakionopeudella pyyhkäisyviivan liikkuessa.
Päätepisteiden reitit eivät leikkaa toisiaan, joten lukuvälit voidaan säilyttää järjestyksessä tavallissa binäärihakupuussa.

Jokainen binääripuussa säilytetty elementti $e$ kuvaa kahden esteen rajaama muuttuvaa lukuväliä.
Kun pyyhkäisyviiva on yhtälön $y=t$ määrittämä suora, merkitään elementin $e$ väliä \intert{t}{e}.
Pyyhkäisyviivan saapuessa pisteeseen $p$ muodostetaan joukon \decomp{c} puolisuunnikkaat niistä binääripuun elementeistä $e$ joilla $p\in\intert{t}{e}$.
Lisäksi puun tila päivitetään vastaamaan pistettä $p$ sivuavia estejanoja.

Jokainen alueen \fspace kärkipiste $p$ on tasan kahden estejanan kärkipiste.
Estejanat voivat olla minkä tahansa joukon $C$ suunnan mukaisia.
Pyyhkäisyviivan tilan muutos riippuu esteiden suunnista.
Jaetaan esteparien suunnat viiteen tapaukseen riippuen miten pyyhkäisyviivan ja alueen \fspace leikkaus muuttuu viivan ohittaessa pisteen $p$.

\begin{enumerate}
\item Estejanat jatkuvat $p$:stä ylöspäin aloittaen vapaan tilan. Tällöin leukkaukseen ilmestyy uusi väli.
\item Janat jatkuvat $p$:stä ylöspäin aloittaen esteen. Yksi leikkauksen väleistä jakaantuu kahdeksi.
\item Janoista toinen jatkuu $p$:stä ylös ja toinen alas. Lukuvälien määrä ei muutu.
\item Janat jatkuvat $p$:stä alaspäin lopettaen esteen. Kaksi lukuväliä yhdistyy yhdeksi.
\item Janat jatkuvat $p$:stä alaspäin lopettaen vapaan tilan. Tilaa vastaava lukuväli poistuu leikkauksesta.
\end{enumerate}

Algoritmin tarkempi kuvaus on seuraava.

\begin{alg}\label{alg:jako2dc}
Tason vapaan tilan jako suorakaiteiden joukoksi \decomp{c}.
\begin{algorithmic}
\State $T\gets \text{tyhjä binäärihakupuu}$
\State $P\gets\text{Alueen \fspace kärkipisteet}$
\State Järjestä joukko $P$ kasvavaan järjestykseen $y$-koordinaatin mukaan.
\ForAll{$p\in P$}
	\State $e_1,e_2 \gets \text{Estevektorit pisteestä } p$
	\If{$\y{e_1}>0$ ja $\y{e_2}>0$}
		\Comment Tapaus 1
	\ElsIf{$\y{e_1}<0$ ja $\y{e_2}<0$}
		\Comment Tapaus 2
	\Else
		\Comment Tapaus 3
	\EndIf

	\If{$e$ aloittaa esteen}
		\Comment Tasan 1 väli $T$:ssä koskettaa väliä \xrange{e}
		\State $v\gets\text{Väliä \xrange{e} koskettava väli puussa $T$}$
		\State $\yranget{v}{2}\gets\y{e}$
		\State Poista väli $v$ puusta $T$
		\ForAll{$u\gets v\setminus s$}
			\State $\yranget{u}{1}\gets\y{e}$
			\State Lisää $v$ listaan $\nbs{u}$
			\State $a\gets\text{Uusi suorakaide}$
			\State $\xrange{a}\gets u$
			\State $\yranget{a}{1}\gets\y{e}$
			\State Lisää $a$ puuhun $T$
		\EndFor
	\Else\Comment $s$ aloittaa vapaan tilan
		\State $a\gets\text{Uusi suorakaide}$
		\State $\xrange{a}\gets\xrange{e}$
		\State $\yranget{a}{1}\gets\y{e}$
		\ForAll{$v\in $ väliä \xrange{e} koskettavat välit puussa $T$}
			\State Lisää $v$ listaan \nbs{a}
			\State $\xrange{a}\gets\xrange{a}\cup\xrange{v}$
			\State Poista $v$ puusta $T$
		\EndFor
		\State Lisää $a$ puuhun $T$.
	\EndIf
\EndFor
\end{algorithmic}
\end{alg}

\begin{lem}\label{lem:jako2dct}Algoritmi~\ref{alg:jako2dc} toimii ajassa $O(n\log n)$.\end{lem}
\begin{proof}HT\end{proof}

\subsubsection{Vaiheittainen valaistus puolisuunnikkaiden joukossa}

Puolisuunnikasjaon avulla voidaan toteuttaa tehokas $C$-suuntainen minimilinkkipolun haku.
Algoritmin ensimmäisenä vaiheena muodostetaan \decomp{c} jokaiselle suunnalle $c\in C$ algoritmilla~\ref{lem:jako2dct}.
Rektilineaarista tapausta mukaillen minimilinkkipolun haku muistuttaa leveyshakua puolisuunnikkaiden joukon $\bigcup_{c\in C}\decomp{c}$ leikkausverkossa.

Askeleella $k$ valaistu tila \reach{k} on yhdistelmä eri joukkojen \decomp{c} puolisuunnikkaista.
Valaistua aluetta ei voida kuvata täydellisesti unionina hajotelmien \decomp{c} osajoukoista, sillä jotkut puolisuunnikkaat ovat valaistu osittain.
Tällöin voidaan esittää jakamalla osa puolisuunnikkaista kahteen tai kolmeen osaan kantojen suuntaisilla janoilla.

Olkoon \reachd{k}{c} niiden pisteiden joukko jotka voidaan saavuttaa $k$ linkillä, kun viimeinen linkki on $c$-suuntainen.
Luonnollisesti $\reach{k}=\bigcup_{c\in C}\reachd{c}{k}$.
Vaiheittaisen valaistun aikana aluetta \reach{k} ylläpidetään tässä muodossa, yhdistelmänä joukkoja \reachd{k}{c} kaikille suunnille $c$.

Vaiheittaisen valaisun askel $k$ muodostaa alueen \reach{k+1} alueesta \reach{k}.
Alue \reachd{k+1}{c} lasketaan tutkimalla mihin pisteisiin päästään siirtymällä suunnassa $c$ lähtien kaikista joukoista \reachd{k}{d}, missä $c\neq d$.
Siis uusi alue lasketaan kaavalla
\begin{equation}\label{eq:reachck}
\reachd{k+1}{c}=\bigcup_{d\neq c} \sweep{\reachd{k}{d}}{c}
\end{equation}
missä \sweep{A}{c} on määritetty kaavan~\eqref{eq:sweep} mukaisesti.

Kaavan~\eqref{eq:reachck} osa \sweep{\reachd{k}{d}}{c} voidaan laskea käyttäen pyyhkäisyyn perustuvaa algoritmia.
Alue \reach{k}{d} esitetään hajotelman \decomp{d} osajoukkona $D$, jossa osa puolisuunnikkaista on leikattu pienemmiksi.
Haluttu alue koostuu joukon \decomp{c} kokonaisista ja leikatuista puolisuunnikkaista, jotka koskettavat aluetta \reach{k}{d}.
On helppo nähdä, että jos jokin puolisuunnikas $d\in D$ lävistää puolisuunnikkaan $c\in\decomp{c}$, niin $c\subseteq\sweep{D}{c}$.
Jos $d$ leikkaa $c$:tä mutta ei vävistä sitä, niin $c$:stä vähintään leikattu osa sisältyy ratkaisuun.

Haetaan aluetta \reach{k}{d} koskettavat joukon \decomp{c} puolisuunnikkaat käyttäen pyyhkäisyviivamenetelmää.
Pyyhkäisyviiva on $c$:n suuntainen, ja liikkuu suuntaan $\rotr{\vec{c}}$.
Esityksen selkeyttämiseksi oletetaan jälleen, että suunta $c$ vastaa $x$-akselia ja $\rotr{\vec{c}}$ osoittaa positiiviseen $y$-akselin suuntaan.

$d$-suuntaisia puolisuunnikkaita leikkaavien $c$-suuntaisten puolisuunnikkaiden haku muistuttaa algoritmin~\ref{alg:light2d} rektilineaarista pyyhkäisyä.
Merkittävänä erona on, että joukkojen \decomp{c} ja \decomp{d} kärkipisteet eivät ole samat, ja pyyhkäisyviivan on pysähdyttävä niissä molemmissa.
Jokainen löydetty joukon \decomp{c} puolisuunnikas valaistaan joko kokonaan tai osittain.
Osittaisessa tapauksessa puolisuunnikkaaseen kirjataan sitä pisimmälle lävistävä $d$-suuntainen puolisuunnikas ylhäältä ja alhaalta (TODO:fig).
Huomaa, että ylhäältä ja alhaalta osittain valaistu puolisuunnikas voi tulla yhteensä kokonaan valaistuksi (TODO:fig).
Algoritmin tarkempi kuvaus on seuraava.

\begin{alg}\label{alg:sweepc}
Laske \sweep{D}{c}, eli $c$-suuntaiset puolisuunnikkaat jotka leikkaavat jotakin $d$-suuntaisten puolisuunnikkaiden joukon $D$ alkiota.
\begin{algorithmic}
\State $Q\gets\text{Joukon $D$ kärkipisteet sisältävä prioriteettijono, järjestetty $y$-koordinaatin mukaan}$.
\State $T\gets\text{Tyhjä binäärihakupuu}$.
\While{$Q$ ei ole tyhjä}
	\State $p\gets\pop{q}$
\EndWhile
\end{algorithmic}
\end{alg}

\begin{lau}\label{lau:clinkt}$C$-suuntainen minimilinkkipolku voidaan laskea ajassa $O(C^2n\log n)$.\end{lau}
\begin{proof}HT\end{proof}

\begin{kor}\label{lau:clinkappr}$C$-suuntaisen minimilinkkipolun 2-approksimaatio voidaan laskea ajassa $O(Cn\log n)$.\end{kor}
\begin{proof}HT\end{proof}


\subsection{Lyhimmän polun kartan muodostus}

\begin{lau}Ajassa $O(n\log n)$ voidaan muodostaa lyhimmän polun kartta, joka kertoo annetulle pisteelle \ept lyhimmän polun pituuden ajassa $O(\log n)$, ja tulostaa lyhimmän polun ajassa $O(\log n + k)$, missä $k$ on polun pituus.\end{lau}
\begin{proof}HT\end{proof}



\section{Rektilineaariset 3D-minimilinkkipolut}\label{sec:link3d}

Tutustumme nyt ongelman~\ref{ong:path} tapaukseen, jossa vapaa alue \fspace on 3-ulotteinen avaruus.
Keskitymme rektilineaariseen tapaukseen, eli aluetta rajaavat estekappaleet, joiden särmät ovat koordinaattiakselien suuntaisia, ja myös haettavan polun linkkien on oltava koordinaattiakselien suuntaisia.

Kaksiulotteisen rektilineaarisen minimilinkkipolkualgoritmin perusideat soveltuvat myös 3-ulotteisen tapauksen ratkaisun pohjaksi:
polku muodostetaan käyttäen vaiheittaista valaistusta, ja jokaisella askeleella \reach{k+1} lasketaan alueesta \reach{k} käyttäen pyyhkäisyyn perustuvaa algoritmia.
Sen sijaan vaikeampi kysymys on, kuinka esittää alue \reach{k} sekä laskea sen perusteella \reach{k+1} tehokkaasti.

Valaistun alueen esittämisessä käytetään kappaleessa~\ref{sec:jako3d} esitettyä hajotelmaa suorakulmaisiin särmiöihin.
Toisin kuin kaksiulotteisessa tapauksessa, algoritmi ei perustu minkään tietyn hajotelman ominaisuuksiin, vaan mikä tahansa hajotelma toimii.
Algoritmin suoritusaika riippuu hajotelman koosta, joten on eduksi käyttää pienintä mahdollista hajotelmaa.

Hajotelmaa käytetään toteuttamaan pyyhkäisytasoalgoritmi, jonka avulla alue \reach{k+1} muodostetaan alueesta \reach{k}.
Jokaisella askeleella suoritetaan 6 pyyhkäisyä, yksi kuhunkin suuntaan $\pm x,\pm y,\pm z$.
Pyyhkäisy suuntaan $d$ laskee alueen \sweep{\reach{k}}{d}, ja yhdistämällä pyyhkäisyt kaikkiin suuntiin saadaan muodostettua koko alue \reach{k+1}.
Pyyhkäisyoperaatiolla on kaksi tehtävää:
löytää ja merkitä uusi valaistu alue, sekä valmistella tietorakenteet seuraavia (alueen \reach{k+2} laskevia) pyyhkäisyjä varten.

\subsection{Valaisu tasopyyhkäisyllä}

Tarkastellaan $+z$-suuntaista pyyhkäisyä $xy$-suuntaisella pyyhkäisytasolla.
Pyyhkäisyn aikana ylläpidetään tietoa mitkä pyyhkäisytason osat tulevat valaistuksi, sekä prioriteettijonoa tapahtumista.
Pyyhkäisytaso pysähtyy tapahtumien kohdalla, joita on kolme tyyppiä:

\begin{itemize}
\item \addrectevt, jonka kohdalla aiemmalla askeleella löydetty valaistu alue lisätään pyyhkäisytasoon.
\item \cellevt tapahtuu kun pyyhkäisytaso saavuttaa solun \emph{suurimman} $z$-koordinaatin.
\item \obsevt tapahtuu kun taso kohtaa estetahkon jonka normaali osoittaa suuntaan $-z$.
\end{itemize}

Tapahtumassa \cellevt jokaiselle naapurille $+z$-suunnassa tarkistetaan, koskettaako naapuri pyyhkäisytason valaistuja suorakaiteita, ja lisätään uusi \cellevt jokaiselle valaistulle naapurille.
Lisäksi jokaiselle esteelle $+z$-suunnassa lisätään \obsevt.
Tapahtumassa \obsevt esteen alue poistetaan pyyhkäisytasosta, ja valaistujen osien reunoista muodostetaan uusia \addrectevt-olioita, joita käytetään seuraavalla askeleella laskemaan \sweep{\reach{k+1}}{\pm x} ja \sweep{\reach{k+1}}{\pm y}.

Pyyhkäisyn aikana säilytetään tietoa valaistavista osisista kappaleessa~\ref{sec:segd} esitetyssä kaksiulotteisessa segmenttipuussa.
Jokainen \addrectevt merkitsee uuden valaistavan alueen segmenttipuuhun.
Valaistun alueen kanonisiin suorakaiteisiin merkitään tieto, mikä \addrectevt sen valaisi.
Jos samaa kanonista suorakaidetta valaisee useampi \addrectevt, säilytetään niistä ensimmäisenä lisätty.

Kun saavutetaan \obsevt, tapahtumaa vastaava suorakaide tyhjennetään segmenttipuussa.
%Koska segmenttipuun tyhjennys vaatii lineaarisen työn, käytetään kappaleessa~\ref{sec:lazyseg} esitettyä laiskaa poistoa.
Tyhjennyksen yhteydessä muodostetaan seuraavalla valaisuaskeleella käytettäviä \addrectevt-olioita poistettavan valaistun alueen reunoille.



\section{Yhteenveto}



\nocite{*}
%\bibliographystyle{plain}
%\bibliographystyle{acm}
\bibliographystyle{ieeetr}
%\bibliographystyle{apalike}

\bibliography{ref}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Malli ABC}

\end{document}
