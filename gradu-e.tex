\documentclass[english,gradu]{tktltiki2018}
\usepackage{epsfig}
%\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx,mathabx}
\usepackage{subfigure,xspace}
\usepackage{algpseudocode}
\begin{document}
\onehalfspacing

\newtheorem{theo}{Theorem}
\newtheorem{lem}[theo]{Lemma}
\newtheorem{cor}[theo]{Corollary}

\theoremstyle{definition}
%\newtheorem{def}[theo]{Definition}
\newtheorem{prob}{Problem}
\newtheorem{alg}{Algorithm}
\newtheorem{ex}{Example}

\theoremstyle{remark}
\newtheorem*{note}{Remark}

\newcommand\range[2]{\ensuremath{\left [ #1 , #2 \right )}\xspace}
\newcommand\orange[2]{\ensuremath{\left ( #1 , #2 \right )}\xspace}
\newcommand\crange[2]{\ensuremath{\left [ #1 , #2 \right ]}\xspace}
\newcommand\set[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand\size[1]{\ensuremath{\left |#1\right |}\xspace}
\newcommand\ceil[1]{\ensuremath{\left\lceil #1\right\rceil}\xspace}
\newcommand\reals{\ensuremath{\mathbb{R}}\xspace}

\newcommand\spt{\ensuremath{\dot{s}}\xspace}
\newcommand\ept{\ensuremath{\dot{t}}\xspace}
\newcommand\fspace{\ensuremath{\mathcal{A}}\xspace}
\newcommand\dirs{\ensuremath{\mathcal{C}}\xspace}

\newcommand\epts{\ensuremath{P}\xspace}
\newcommand\segsize{\ensuremath{m}\xspace}
\newcommand\inter[1]{\ensuremath{\textsc{intr}(#1)}\xspace}
\newcommand\leftc[1]{\ensuremath{\textsc{left}(#1)}\xspace}
\newcommand\rightc[1]{\ensuremath{\textsc{right}(#1)}\xspace}
\newcommand\reach[1]{\ensuremath{\textsc{light}(#1)}\xspace}
\newcommand\reachd[2]{\ensuremath{\textsc{light}_{#2}(#1)}\xspace}
\newcommand\canon[1]{\ensuremath{\bar{\textsc{c}}(#1)}\xspace}
\newcommand\canonp[1]{\ensuremath{\dot{\textsc{c}}(#1)}\xspace}
\newcommand\canont[2]{\ensuremath{\textsc{c}(#1,#2)}\xspace}
\newcommand\canoni[2]{\ensuremath{\textsc{c}_{#2}(#1)}\xspace}
\newcommand\canonpar[1]{\ensuremath{\textsc{p}_{\textsc{c}}(#1)}\xspace}
\newcommand\epar[1]{\ensuremath{\textsc{p}(#1)}\xspace}
\newcommand\visitp{\ensuremath{\textsc{VisitParent}}\xspace}
\newcommand\visitc{\ensuremath{\textsc{VisitCanonical}}\xspace}

\newcommand\pop[1]{\ensuremath{\textsc{pop}(#1)}\xspace}

\newcommand\y[1]{\ensuremath{{#1}_y}\xspace}
\newcommand\x[1]{\ensuremath{{#1}_x}\xspace}
\newcommand\xrange[1]{\ensuremath{x(#1)}\xspace}
\newcommand\yrange[1]{\ensuremath{y(#1)}\xspace}
\newcommand\zrange[1]{\ensuremath{z(#1)}\xspace}
\newcommand\xranget[2]{\ensuremath{x(#1)_{#2}}\xspace}
\newcommand\yranget[2]{\ensuremath{y(#1)_{#2}}\xspace}
\newcommand\nbs[1]{\ensuremath{\textsc{nbs}{(#1)}}\xspace}
\newcommand\nbsd[2]{\ensuremath{\textsc{nbs}_{#2}{(#1)}}\xspace}

\newcommand\decomp[1]{\ensuremath{\textsc{dec}_{#1}}\xspace}
%\newcommand\decompc[1]{\ensuremath{\textsc{hajo}({#1})}\xspace}
\newcommand\sweep[2]{\ensuremath{\textsc{sweep}_{#2}{(#1)}}\xspace}
\newcommand\stepof[1]{\ensuremath{\textsc{step}{(#1)}}\xspace}
\newcommand\proj[2]{\ensuremath{\text{proj}_{#1}(#2)}\xspace}

\newcommand\rotr[1]{\ensuremath{\top #1}\xspace}
\newcommand\vecof[1]{\ensuremath{\left [#1\right ]}\xspace}
\newcommand\sline[1]{\ensuremath{S_{#1}}\xspace}
\newcommand\intert[2]{\ensuremath{\textsc{interval}_{#1}(#2)}\xspace}
\newcommand\point[1]{\ensuremath{\left ({#1}\right )}\xspace}

\newcommand\cellevt{\ensuremath{\texttt{CellEvent}}\xspace}
\newcommand\obsevt{\ensuremath{\texttt{ObstacleEvent}}\xspace}
\newcommand\addrectevt{\ensuremath{\texttt{AddRectEvent}}\xspace}


\title{Minimum Link Paths In Two and More Dimensions}
\author{Mikko Sysikaski}
\date{\today}
\level{Master's thesis}

% For new study programmes (2017->) to appear on title page
%\department{Master's Programme in Computer Science}
%\department{Master's Programme in Data Science}
%\department{Bachelor's Programme in Computer Science}

\maketitle

\numberofpagesinformation{\numberofpages\ pages + \numberofappendixpages\ appendices}

%\classification{\protect{\ \\
%\  General and reference $\rightarrow$ Document types  $\rightarrow$ Surveys and overviews\  \\
%\  Applied computing  $\rightarrow$ Document management and text processing  $\rightarrow$ Document management $\rightarrow$ Text editing\\
%}}

\keywords{algorithms, computational geometry}

\supervisors{Antti Laaksonen and Jyrki Kivinen}

%default (40 cr thesis)
%\program{Computer Science}

%Computer Science Master's Programme thesis, 30 cr
%\program{Study Programme in Computer Science} 

%Data Science thesis, 30 cr
%\program{Master's Programme in Data Science}

%Bachelor's thesis 
%\level{Bachelor's thesis}
%Computer Science Bachelor's Programme (2017->) thesis
%\program{Bachelor's Programme in Computer Science}

% For CS Master's Programme thesis 2017->
%\additionalinformation{Thesis for the Algorithms study track }
%\additionalinformation{Thesis for the Networking and Services study track}
%\additionalinformation{Thesis for the Software Systems study track}

% For CS Master's thesis if you follow CS degree requirements prior 2017
%\additionalinformation{Thesis for the Algorithmic Bioinformatics subprogramme}
\additionalinformation{Thesis for the Algorithms, Data Analytics and Machine Learning subprogramme}
%\additionalinformation{Thesis for the Networking and Services subprogramme}
%\additionalinformation{Thesis for the Software Systems subprogramme}

%\level{Seminar essay}
%\additionalinformation{Essay for Seminar on ...}

\begin{abstract}
The thesis subject are algorithms for minimum link path computation.
Minimum link path is a geometric path that consists of straight line segments and does a minimal number of turns.
We present new algorithms to several variations of the minimum link path problem.
\end{abstract}

\mytableofcontents




\section{Introduction}

Path finding problems are a widely studied subject in algorithmics.\cite{survey}
A typical task is finding the shortest path between two nodes in a graph.
Geometric version of the problem asks for the shortest path in a continuous space, such as plane with polygonal obstacles.
The typical task is to minimize the Euclidean length of the path, but there are other relevant metrics as well.
For example a robot might move forward fast, but be slow at corners, so a long simple route is sometimes preferable to a shorter but more complex route.

The topic of this thesis is finding geometric path the do minimum amount of turns.
Consider a path consisting of a finite number of straight line segments.
The \emph{link distance} of the path is the number of segments.
A \emph{minimum link path} between two points is a path that minimizes the link distance.

Finding minimum link paths is a well studied algorithmic problem.
The basic idea employed by most known algorithms is a simple extension of bredth-first search:
First find points that have link distance~1 to the starting point, then points with link distance~2, and similarly iterate until the desired endpoint is encountered.
Since the search happens in continuous space, the hard part of the algorithms is defining the appropriate data structures to store and update the discovered area.

In this thesis we focus on variants of the problem where the possible directions of the edges of the path are limited.
In $C$-oriented problem we are given a set $C$ of possible directions that the edges can take.
For the $C$-oriented problem, we present a new algorithm that works in time $O(C^2n\log n)$~\cite{revisited}.
We also study 3D version of the problem for a case where the only allowed directions are the coordinate axes.
For this problem we present a new algorithm that works in time $O(n^2\log^2n)$, which is a significant improvement over the earlier best known result $O(n^{2.5}\log n)$.\cite{restricted}
Finally, we extend the 3D solution to work in $D$-dimensional domains in time $O(n^D\log^Dn)$.

\subsection{Problem description}

The definition of the minimum link path problem is the following.
\begin{prob}\label{prob:path}
We are given a description of free space \fspace and two points $\spt\in\fspace$ and $\ept\in\fspace$.
The task is to find a path from \spt to \ept in \fspace with minimum link distance.
\end{prob}

Typically the algorithms for pathfinding start from one of the points, and search the area until the other point is found.
Often this approach allows us to create a data structure that can be used to efficiently find a path between \spt and any other point.
Thus the same algorithms can be applied to solve a problem where \ept is given only afterwards.

\begin{prob}\label{prob:map}
We are given a description of free space \fspace and a point $\spt\in\fspace$.
Construct a data structure that allows finding the minimum link path between \spt and any given point.
\end{prob}

\subsection{Overview of algorithms}\label{sec:overview}

All the known algorithms for the minimum link path problem use the same basic idea:
The tasks is to find a minimum link path from point \spt to point \ept.
Let \reach{k} be the set of points reachable by at most $k$ links from \spt.
Start by defining $\reach{0}=\set{\spt}$, and iteratively compute \reach{k+1} from \reach{k}.
The iteration continues until we find $k$ such that $\ept\in\reach{k}$.
This iteration is often called \emph{staged illumination}, because the computation of \reach{k+1} can be illustrated by setting a light source in all points of \reach{k}, and selecting all the lit points.

This process closely resembles the bredth-first search, but a key difference is that the search is done in continuous space rather than in a graph.
A nontrivial part in any minimum link path algorithm is maintaining the illuminated area in a data structure that allows efficient computation of \reach{k+1} from \reach{k}.

Representing the illuminated area can be simplified by first splitting the free space into simple primitives.
A common approach in computational geometry is to start by triangulating the input, which allows working with simple forms.
In case of minimum link paths with restricted orientations, rectangles or trapezoids are the most comfortable representations.
In section~\ref{sec:decomposition} we present algorithms for construction decompositions suitable for minimum link path computation.

With restricted orientations that the paths can take, we can use \emph{sweep line algorithms} to efficiently compute \reach{k+1} from \reach{k}.
The idea is to "sweep" over the search space by a line, and use the sweep to calculate how the path can advance into the direction of the sweep line.
This generic technique allows us to transform the 2-dimensional illumination problem into a series of easier 1-dimensional problems on the sweep line.
The sweep line technique is discussed in section~\ref{sec:sweep}.

During the sweeps we need to maintain the relationship between the sweep line and the obstacles as well as the region \reach{k}.
Maintaining this kind of information requires efficient handling of 1-dimensional intervals.
\emph{Segment tree} is a generic data structure for working with intervals.
It can be used to efficiently implement all the operations required by the staged illumination.
Segment trees are described in section~\ref{sec:segtree}.

We combine the aforementioned concepts into an algorithm for finding minimum link paths in section~\ref{sec:minlink2d}.
The ideas of the two-dimensional solution can also be generalized to work in higher dimensions.
Many details need to be taken care of, but the basic ideas are relatively straightforward to transfer to more than two dimensions.
The space is decomposed into cuboids instead of rectangles, and the sweep line is replaced by a sweep plane.
The segment tree can also be generalized into a higher dimensional structure.
These elements are combined into an algorithm for finding minimum link paths in higher dimensional domains in section~\ref{sec:minlink3d}.



\section{Space decomposition}\label{sec:decomposition}

The domain of the minimum link path problem is a polygon with smaller polygons as obstacles.
The input is given as a list of polygons, and each polygon is described by a list of vertices.
This form is inconvenient for path planning algorithms, as many simple operations, such as checking whether we can move from a given point to given direction, require scanning through all the polygons.

In the rectilinear minimum link path problem the obstacle edges are oriented according to the coordinate axis.
This allows us to decomposition the free space into rectangles, which is a convenient form for rectilinear path computation.
For each cell of the decomposition we also construct links to neighboring cells and obstacles.
In other words, the decomposition is a graph with rectangles as vertices and an edge between each pair of adjacent rectangles.
If the total number of edges in all the obstacles is $n$, we can decompose the space into $O(n)$ cells such the total number of links between cells is also $O(n)$.

A similar structure can also be used for computing minimum link paths in 3-dimensional domains.
In 3D rectilinear case each obstacle face is a polygon with axis-aligned edges in 3D space.
In this case the free space can be decomposed into a graph with $O(n^2)$ cuboid as vertices and $O(n^2)$ edges.


\subsection{Sweep line algorithms}\label{sec:sweep}

Sweep line algorithms are a generic technique used for a wide range of computational geometry problems.
The idea is to image a line that crosses over the domain.
As the sweep line progresses, we gradually update the solution to take into account the parts of the domain that the line has crossed.
Conceptually the sweep line moves continuously in space, but in practice we only process a discrete set of \emph{events} where some structural change to the solution happens.


\subsection{Planar decomposition}\label{sec:decomp2d}

A rectilinear domain can be decomposed into rectangles by extending each horizontal obstacle edge in both directions until the sides hit a vertical obstacle edge.
This defines the \emph{horizontal decomposition} of the domain, denoted \decomp{x}.
The vertical decomposition \decomp{y} is defined correspondingly by extending all the vertical edges until they hit a horizontal obstacle.

It is easy to see that each cell of \decomp{x} touches at least one obstacle vertex.
Since each vertex can be touched by at most two rectangles, the size of the decomposition is $O(n)$.
Each pair of touching rectangles also shares a common obstacle corner, so the number of links is also $O(n)$.

\decomp{x} can be constructed with a line sweep algorithm.
We sweep over the domain by a horizontal line moving from $y$ coordinate $-\infty$ (down) to $\infty$ (up).
During the sweep we maintain the intersection of the free space \fspace and the sweep line.
The intersection consists of non-overlapping intervals, which we store in a binary search tree.

Each element added to the binary tree is a partially constructed rectangle $a$ with the following fields.
\begin{itemize}
\item Interval $\xrange{a}=\range{\xranget{a}{1}}{\xranget{a}{2}}$.
\item Interval $\yrange{a}=\range{\yranget{a}{1}}{\yranget{a}{2}}$.
\item List of neighbor links $\nbs{a}$.
\end{itemize}

The sweep stops at each horizontal obstacle edge.
When moving from down to up, each edge starts either starts or ends an obstacle.
If the edge starts an obstacle, the $x$-range of the edge is fully contained in one of the intervals in the search tree.
If the edge ends an obstacle, the $x$-range does not intersect any intervals in the tree, but the left and right endpoints may touch some intervals.
In both cases the intervals touching the encountered edge are removed from the search tree, and $O(1)$ new intervals are inserted to maintain the sweep line state.
A more exact description of the algorithm follows below.

\begin{alg}\label{alg:split2d}
Decomposition of \fspace into a group of rectangular cells \decomp{x}.
\begin{algorithmic}
\State $T\gets \text{Empty binary search tree}$.
\State $E\gets\text{All horizontal obstacle edges}$.
\State Sort $E$ by the $y$ coordinates of the edges.
\ForAll{$e\in E$}
	\If{$e$ starts an obstacle}
		\Comment Exactly one interval in $T$ intersects \xrange{e}.
		\State $v\gets\text{Lookup $T$ for interval touching \xrange{e}}$.
		\State Remove $v$ from $T$.
		\State $\yranget{v}{2}\gets\y{e}$.
		\ForAll{$u\gets v\setminus s$}
			\State $\yranget{u}{1}\gets\y{e}$.
			\State Insert $v$ to list $\nbs{u}$.
			\State $a\gets\text{New rectangle}$.
			\State $\xrange{a}\gets u$.
			\State $\yranget{a}{1}\gets\y{e}$.
			\State Insert $a$ to tree $T$.
		\EndFor
	\Else\Comment $e$ starts free space.
		\State $a\gets\text{New rectangle}$
		\State $\xrange{a}\gets\xrange{e}$.
		\State $\yranget{a}{1}\gets\y{e}$.
		\ForAll{$v\in$ lookup $T$ for intervals touching \xrange{e}}
			\State Remove $v$ from $T$.
			\State Insert $v$ to list \nbs{a}.
			\State $\xrange{a}\gets\xrange{a}\cup\xrange{v}$.
		\EndFor
		\State Insert $a$ to $T$.
	\EndIf
\EndFor
\end{algorithmic}
\end{alg}

The complexity of the algorithm can be easily bounded.

\begin{lem}\label{lem:split2dtime}Algorithm~\ref{alg:split2d} works in time $O(n\log n)$ and space $O(n)$.\end{lem}
\begin{proof}
The algorithm sorts all the horizontal edges in time $O(n\log n)$, and iterates over them in $O(n)$ steps.
On each step we emit $O(1)$ cells and neighbor links, and perform $O(1)$ operations to the binary search tree.
The search tree is a balanced binary tree, so each operation to it is carried out in time $O(\log n)$.
Thus the total complexity of the algorithm is $O(n\log n)$, and we only need $O(n)$ storage for the edge list and the binary search tree.
\end{proof}

\subsection{3D cuboid decomposition}

Similarly as a 2D domain can be decomposed into rectangles, a 3D rectilinear domain can be decomposed into cuboids.
Decomposition into cuboids is used in the algorithm for 3D minimum link paths in section~\ref{sec:minlink3d}.
The running time of the path finding algorithm is heavily depent on the size of the decomposition, so it is desirable to find as small decomposition as possible.

The input is given as a list of 2-dimensional obstacle faces in 3-dimensional space.
Each obstacle face is a polygon defined by a list of vertices.
Denote the total number of vertices by $n$.

We present a simple algorithm that uses the algorithm~\ref{alg:split2d} as a subroutine.
This algorithm produces a decomposition with $O(n^2)$ cells and $O(n^2)$ links.
There also exists algorithms for finding decompositions with even small number of cells, but the worst case for number of links is superquadratic for all the known solutions.

The solution is a sweep plane algorithm, whichi sweeps through the domain with a plane perpendicular to $z$-axis.
During the sweep we maintain the intersection of the sweep plane and the domain~\fspace.
The intersection of the domain and a plane is called a \emph{cross section} of the domain.

In each cross section we form a 2D decomposition of the domain with algorithm~\ref{alg:split2d}, and extend the $xy$-rectangles in $z$-direction so that they fill the whole free space.
Any common rectangles shared by consecutive cross sections are merged into a single larger cuboid.
The merging is done by by maintaining a binary search tree of the cells of the previous decomposition.

The description below only calculates the cells, but not the links between them.
We discuss the computation of links below.

\begin{alg}\label{alg:split3d}
Decompose the free space defined by a set $E$ of obstacle faces into cuboids.
\begin{algorithmic}
\State $Z\gets$ All $z$-coordinates of obstacle vertices.
\State Sort $Z$ in increasing order.
\State $R\gets$ Empty list of result cells.
\State $M\gets$ Empty binary search tree mapping 2D rectangles to indices in $R$.
\ForAll{$z\in Z$}
	\State $E_z\gets\set{e \mid e\in E, \zrange{e}\ni z}$.
	\State $T\gets$ 2D decomposition for $E_z$ using algorithm~\ref{alg:split2d}.
	\ForAll{$m\in M\setminus T$}
		\State $c\gets R[M[m]]$.
		\State Upper $z$-coordinate of $c\gets z$.
		\State Remove $m$ from $M$.
	\EndFor
	\ForAll{$t\in T\setminus M$}
		\State $c\gets$ New cell with $xy$-bounds $t$ and starting $z$-coordinate $z$.
		\State Insert $c$ into $R$.
		\State $M[t]\gets$ index of $c$ in $R$.
	\EndFor
\EndFor
\State Return list $R$.
\end{algorithmic}
\end{alg}

The running time of the algorithm is easy to determine using Lemma~\ref{lem:split2dtime}.

\begin{lem}\label{lem:split3dtime}Algorithm~\ref{alg:split3d} has running time $O(n^2\log n)$.\end{lem}
\begin{proof}
We loop through $O(n)$ unique $z$-coordinates.
For each $z$ we construct a set of obstacles in time $O(n)$ and a 2D decomposition in time $O(n\log n)$.
The map $M$ is implemented as a binary search tree, so each update and lookup can be performed in time $O(\log n)$.
For each $z$ we perform $O(n)$ such updates, so the total time bound is $O(n^2\log n)$.
\end{proof}

Algorithm~\ref{alg:split3d} divides the space into cuboids, but does not generate any links between them.
First we bound the number of links.
The following lemma helps in the analysis.

\begin{lem}\label{lem:decomp2dch}
Consider two obstacle sets $A$ and $B$ on 2D plane.
Let $n$ be the total number of obstacle edges in any of them, and $k$ be the number of edges that are present in exactly one of the sets.
The number of overlapping rectangles in \decomp{x}(A) and \decomp{x}(B) is $O(nk)$.
\end{lem}
\begin{proof}
Consider how the sweep line of algorithm~\ref{alg:split2d} advances in domains $A$ and $B$.
Recall that the sweep line is a horizontal line moving in $y$-direction.

The intersection of the sweep line and the free space is a sequence of disjoint intervals for both $A$ and $B$.
Since there are $O(k)$ changes to the set of obstacles, the edit distance between the interval sets is $O(k)$.
Thus each $y$ coordinate contributes $O(k)$ pairs to the overlap.
Since the number of $y$ coordinates where the domain changes is $O(n)$, the total number of overlapping pairs is $O(nk)$.
\end{proof}

\begin{lem}The number of pairs of adjacent cells in the decomposition produced by algorithm~\ref{alg:split3d} is $O(n^2)$.\end{lem}
\begin{proof}
Since the number of links produced by algorithm~\ref{alg:split2d} is $O(n)$, any cross section has $O(n)$ links in $x$ and $y$ directions.
Thus the total number of $x$ and $y$ links is $O(n^2)$.

Let $k_z$ be the number of different obstacles on the cross sections on planes $z=z_k-\varepsilon$ and $z=z_k+\varepsilon$.
Since the total number of obstacles is $n$, the sum of different $k_z$ values is $n$.
The number of links between two adjacent layers is $O(nk_z)$ by Lemma~\ref{lem:decomp2dch}.
Summing up all the changes gives the desired bound $\sum_z O(nk_z) = O(n^2)$.
\end{proof}

Since we know how to compute links for 2D decomposition, the links in $x$ and $y$ directions can easily be obtained from the cross sections.
What remains is computing the links in $z$ direction.
We compute the links between each pair of adjacent cross sections separately.

Let $A$ and $B$ be the sets of rectangles that are different on the horizontal decompositions of two adjacent cross sections.
Finding the $z$-links in the 3D decomposition is equivalent to finding the set of overlapping pairs between $A$ and $B$.
The pairs are found by running \emph{another} line sweep algorithm after both $A$ and $B$ have been created by algorithm~\ref{alg:split2d}.

We sweep through the domain again by a horizontal line.
During the sweep we maintain two binary search tree $T_A$ and $T_B$, containing the rectangles of $A$ and $B$ touching the sweep line respectively.
The binary search tree is ordered by the $x$-coordinate of the rectangle.
Note that the rectangles in each of the sets $A$ and $B$ are disjoint, so the $x$-ranges are disjoint as well.

Each time the sweep line arrives into a new rectangle $a\in A$, the tree $T_B$ is queries to find all the rectangles touched by the bottom line of $a$.
Similarly for each new rectangle $b\in B$, we query the tree $T_A$ for rectangles touching the bottom line of $b$.
A more exact description of the algorithm is below.

\begin{alg}\label{alg:overlap2d}
Find all overlapping pairs of two sets of rectangles $A$ and $B$.
\begin{algorithmic}
\State $E\gets$ All bottom and top edges of rectangles in $A$ and $B$.
\State Sort $E$ by $y$-coordinate.
\State $T_A\gets$ Empty binary search tree.
\State $T_B\gets$ Empty binary search tree.
\ForAll{$e\in E$}
	\State $s\in\set{A,B}\gets$ Group to which $e$ belongs to.
	\State $t\in\set{A,B}\gets$ Group to which $e$ does not belong to.
	\If{$e$ starts a rectangle}
		\State Find all elements from $T_t$ with $x$-range intersection the $x$-range of $e$.
		\State Add the rectangle to $T_x$.
	\Else
		\State Remove the rectangle from $T_x$.
	\EndIf
\EndFor
\end{algorithmic}
\end{alg}

\begin{lem}\label{lem:overlap2dtime}Algorithm~\ref{alg:overlap2d} runs in time $O(n\log n + k)$, where $n$ is the total size of $A$ and $B$, and $k$ is the number of overlapping pairs.\end{lem}
\begin{proof}
First we sort all the top and bottom edges in the input in time $O(n\log n)$.
We then iterate over all the edges, performing 3 kinds of tree operations: add, remove and lookup.

Each add and lookup operation takes $O(\log n)$ time in a balanced binary search tree.
The lookup of elements intersecting the given element is done by first finding the leftmost intersecting element in the tree, and then scanning adjacent tree nodes until all the intersecting elements have been found.
This requires time $O(\log n+u)$ where $u$ is the number of overlapping pairs.

Combining the time for sorting, tree additions, deletions and lookups, the total complexity is $O(n\log n + k)$.
\end{proof}


\subsection{Higher dimensional decomposition}




\section{Segment tree}\label{sec:segtree}

Segment tree is a data structure for working with one-dimensional number intervals.
The structure implementing a wide range of operations in logarithmic time.
Some example of operations that can be implemented include:
\begin{itemize}
	\item Insert and remove interval to the tree.
	\item Find all the intervals intersecting a given query interval.
	\item Cut of a given range from all the ranges in the tree.
\end{itemize}

Rather than as a single data structure that is used as a black box, the segment trees are better viewed as a framework that can be adapted to work in various situations.
It is straightforward to augment the tree to contain additional information about the intervals, and use the information in queries.
For example we can associate a number with each interval, and allow efficiently querying for the maximum number overlapping a given query interval.
We first present the overal idea of the tree, and then show how it can be applied to the minimum link path problem.

Segment trees are typically implemented as semi-dynamic structures.
This means that the tree can be efficiently modified after it has been build, but we need to specify the set of possible endpoints \epts of intervals in advance.
This allows implementing most operations in time $O(\log m)$, and the size of the tree is $O(m)$, where $m=\size{\epts}$.

\subsection{Structure of a segment tree}

A segment tree is a binary tree where each node $n$ corresponds to a fixed half-open interval $\inter{n}$.
Each branch node $s$ has two child nodes \leftc{s} and \rightc{s}.
The intervals of the children divide the parent interval into two parts:
$\inter{s}=\inter{\leftc{s}}\cup\inter{\rightc{s}}$, $\inter{\leftc{s}}\cap\inter{\rightc{s}}=\emptyset$.
The root node corresponds the largest supported interval \range{\epts[1]}{\epts[m]}, and the leaf nodes correspond to the smallest possible intervals \range{\epts[i]}{\epts[i+1]}.

The structure of a semi-dynamic segment tree is independent of the intervals added to the tree.
Thus we can make the structure into an almost complete binary tree, which allows storing the tree nodes in an array similarly to binary heap:
the root node is stored in index~1, and the child nodes of node $i$ are $2i$ and $2i+1$.
This representation has very good constant factors, making segment tree a powerful practical tool rather than only a theoretical construct.

\subsection{Canonical nodes}

When an interval $I$ is added to the tree, it is added to several tree nodes called the \emph{canonical nodes} of $I$, denoted by \canon{I}.
The canonical nodes of $I$ are the smallest set of nodes whose intervals cover $I$ but nothing else: $\cup_{c\in\canon{I}} \inter{c}=I$.

\section{Planar minimum link paths}\label{sec:minlink2d}

\section{Paths in 3 and higher dimensions}\label{sec:minlink3d}

\section{Conclusions}\label{sec:conclusions}


\nocite{*}
\bibliographystyle{tktl}
\bibliography{ref}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Model ABC}

\end{document}


