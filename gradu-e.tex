\documentclass[english,gradu]{tktltiki2018}
\usepackage{epsfig}
%\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx,mathabx}
\usepackage{subfigure,xspace}
\usepackage{algpseudocode}
\begin{document}
\onehalfspacing

\newtheorem{theo}{Theorem}
\newtheorem{lem}[theo]{Lemma}
\newtheorem{cor}[theo]{Corollary}

\theoremstyle{definition}
%\newtheorem{def}[theo]{Definition}
\newtheorem{prob}{Problem}
\newtheorem{alg}{Algorithm}
\newtheorem{ex}{Example}

\theoremstyle{remark}
\newtheorem*{note}{Remark}

\newcommand\range[2]{\ensuremath{\left [ #1 , #2 \right )}\xspace}
\newcommand\orange[2]{\ensuremath{\left ( #1 , #2 \right )}\xspace}
\newcommand\crange[2]{\ensuremath{\left [ #1 , #2 \right ]}\xspace}
\newcommand\set[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand\size[1]{\ensuremath{\left |#1\right |}\xspace}
\newcommand\ceil[1]{\ensuremath{\left\lceil #1\right\rceil}\xspace}
\newcommand\reals{\ensuremath{\mathbb{R}}\xspace}

\newcommand\spt{\ensuremath{\dot{s}}\xspace}
\newcommand\ept{\ensuremath{\dot{t}}\xspace}
\newcommand\fspace{\ensuremath{\mathcal{A}}\xspace}
\newcommand\dirs{\ensuremath{\mathcal{C}}\xspace}

\newcommand\epts{\ensuremath{P}\xspace}
\newcommand\segsize{\ensuremath{m}\xspace}
\newcommand\inter[1]{\ensuremath{\textsc{interval}(#1)}\xspace}
\newcommand\leftc[1]{\ensuremath{\textsc{left}(#1)}\xspace}
\newcommand\rightc[1]{\ensuremath{\textsc{right}(#1)}\xspace}
\newcommand\reach[1]{\ensuremath{\textsc{light}(#1)}\xspace}
\newcommand\reachd[2]{\ensuremath{\textsc{light}_{#2}(#1)}\xspace}
\newcommand\canon[1]{\ensuremath{\bar{\textsc{c}}(#1)}\xspace}
\newcommand\canonp[1]{\ensuremath{\dot{\textsc{c}}(#1)}\xspace}
\newcommand\canont[2]{\ensuremath{\textsc{c}(#1,#2)}\xspace}
\newcommand\canoni[2]{\ensuremath{\textsc{c}_{#2}(#1)}\xspace}
\newcommand\canonpar[1]{\ensuremath{\textsc{p}_{\textsc{c}}(#1)}\xspace}
\newcommand\epar[1]{\ensuremath{\textsc{p}(#1)}\xspace}
\newcommand\visitp{\ensuremath{\textsc{VisitParent}}\xspace}
\newcommand\visitc{\ensuremath{\textsc{VisitCanonical}}\xspace}

\newcommand\pop[1]{\ensuremath{\textsc{pop}(#1)}\xspace}

\newcommand\y[1]{\ensuremath{{#1}_y}\xspace}
\newcommand\x[1]{\ensuremath{{#1}_x}\xspace}
\newcommand\xrange[1]{\ensuremath{x(#1)}\xspace}
\newcommand\yrange[1]{\ensuremath{y(#1)}\xspace}
\newcommand\zrange[1]{\ensuremath{z(#1)}\xspace}
\newcommand\xranget[2]{\ensuremath{x(#1)_{#2}}\xspace}
\newcommand\yranget[2]{\ensuremath{y(#1)_{#2}}\xspace}
\newcommand\nbs[1]{\ensuremath{\textsc{neighb}{(#1)}}\xspace}
\newcommand\nbsd[2]{\ensuremath{\textsc{neighb}_{#2}{(#1)}}\xspace}

\newcommand\decomp[1]{\ensuremath{\textsc{dec}_{#1}}\xspace}
%\newcommand\decompc[1]{\ensuremath{\textsc{hajo}({#1})}\xspace}
\newcommand\sweep[2]{\ensuremath{\textsc{sweep}_{#2}{(#1)}}\xspace}
\newcommand\stepof[1]{\ensuremath{\textsc{step}{(#1)}}\xspace}
\newcommand\proj[2]{\ensuremath{\text{proj}_{#1}(#2)}\xspace}

\newcommand\rotr[1]{\ensuremath{\top #1}\xspace}
\newcommand\vecof[1]{\ensuremath{\left [#1\right ]}\xspace}
\newcommand\sline[1]{\ensuremath{S_{#1}}\xspace}
\newcommand\intert[2]{\ensuremath{\textsc{interval}_{#1}(#2)}\xspace}
\newcommand\point[1]{\ensuremath{\left ({#1}\right )}\xspace}

\newcommand\cellevt{\ensuremath{\texttt{CellEvent}}\xspace}
\newcommand\obsevt{\ensuremath{\texttt{ObstacleEvent}}\xspace}
\newcommand\addrectevt{\ensuremath{\texttt{AddRectEvent}}\xspace}


\title{Minimum Link Paths In Two and More Dimensions}
\author{Mikko Sysikaski}
\date{\today}
\level{Master's thesis}

% For new study programmes (2017->) to appear on title page
%\department{Master's Programme in Computer Science}
%\department{Master's Programme in Data Science}
%\department{Bachelor's Programme in Computer Science}

\maketitle

\numberofpagesinformation{\numberofpages\ pages + \numberofappendixpages\ appendices}

%\classification{\protect{\ \\
%\  General and reference $\rightarrow$ Document types  $\rightarrow$ Surveys and overviews\  \\
%\  Applied computing  $\rightarrow$ Document management and text processing  $\rightarrow$ Document management $\rightarrow$ Text editing\\
%}}

\keywords{algorithms, computational geometry}

\supervisors{Antti Laaksonen and Jyrki Kivinen}

%default (40 cr thesis)
%\program{Computer Science}

%Computer Science Master's Programme thesis, 30 cr
%\program{Study Programme in Computer Science} 

%Data Science thesis, 30 cr
%\program{Master's Programme in Data Science}

%Bachelor's thesis 
%\level{Bachelor's thesis}
%Computer Science Bachelor's Programme (2017->) thesis
%\program{Bachelor's Programme in Computer Science}

% For CS Master's Programme thesis 2017->
%\additionalinformation{Thesis for the Algorithms study track }
%\additionalinformation{Thesis for the Networking and Services study track}
%\additionalinformation{Thesis for the Software Systems study track}

% For CS Master's thesis if you follow CS degree requirements prior 2017
%\additionalinformation{Thesis for the Algorithmic Bioinformatics subprogramme}
\additionalinformation{Thesis for the Algorithms, Data Analytics and Machine Learning subprogramme}
%\additionalinformation{Thesis for the Networking and Services subprogramme}
%\additionalinformation{Thesis for the Software Systems subprogramme}

%\level{Seminar essay}
%\additionalinformation{Essay for Seminar on ...}

\begin{abstract}
The thesis subject are algorithms for minimum link path computation.
Minimum link path is a geometric path that consists of straight line segments and does a minimal number of turns.
We present new algorithms to several variations of the minimum link path problem.
\end{abstract}

\mytableofcontents




\section{Introduction}

Path finding problems are a widely studied subject in algorithmics.\cite{survey}
A typical task is finding the shortest path between two nodes in a graph.
Geometric version of the problem asks for the shortest path in a continuous space, such as plane with polygonal obstacles.
The typical task is to minimize the Euclidean length of the path, but there are other relevant metrics as well.
For example a robot might move forward fast, but be slow at corners, so a long simple route is sometimes preferable to a shorter but more complex route.

The topic of this thesis is finding geometric path the do minimum amount of turns.
Consider a path consisting of a finite number of straight line segments.
The \emph{link distance} of the path is the number of segments.
A \emph{minimum link path} between two points is a path that minimizes the link distance.

Finding minimum link paths is a well studied algorithmic problem.
The basic idea employed by most known algorithms is a simple extension of bredth-first search:
First find points that have link distance~1 to the starting point, then points with link distance~2, and similarly iterate until the desired endpoint is encountered.
Since the search happens in continuous space, the hard part of the algorithms is defining the appropriate data structures to store and update the discovered area.

In this thesis we focus on variants of the problem where the possible directions of the edges of the path are limited.
In $C$-oriented problem we are given a set $C$ of possible directions that the edges can take.
For the $C$-oriented problem, we present a new algorithm that works in time $O(C^2n\log n)$~\cite{revisited}.
We also study 3D version of the problem for a case where the only allowed directions are the coordinate axes.
For this problem we present a new algorithm that works in time $O(n^2\log^2n)$, which is a significant improvement over the earlier best known result $O(n^{2.5}\log n)$.\cite{restricted}
Finally, we extend the 3D solution to work in $D$-dimensional domains in time $O(n^D\log^Dn)$.

\subsection{Problem description}

The definition of the minimum link path problem is the following.
\begin{prob}\label{prob:path}
We are given a description of free space \fspace and two points $\spt\in\fspace$ and $\ept\in\fspace$.
The task is to find a path from \spt to \ept in \fspace with minimum link distance.
\end{prob}

Typically the algorithms for pathfinding start from one of the points, and search the area until the other point is found.
Often this approach allows us to create a data structure that can be used to efficiently find a path between \spt and any other point.
Thus the same algorithms can be applied to solve a problem where \ept is given only afterwards.

\begin{prob}\label{prob:map}
We are given a description of free space \fspace and a point $\spt\in\fspace$.
Construct a data structure that allows finding the minimum link path between \spt and any given point.
\end{prob}

\subsection{Overview of algorithms}\label{sec:overview}

All the known algorithms for the minimum link path problem use the same basic idea:
The tasks is to find a minimum link path from point \spt to point \ept.
Let \reach{k} be the set of points reachable by at most $k$ links from \spt.
Start by defining $\reach{0}=\set{\spt}$, and iteratively compute \reach{k+1} from \reach{k}.
The iteration continues until we find $k$ such that $\ept\in\reach{k}$.
This iteration is often called \emph{staged illumination}, because the computation of \reach{k+1} can be illustrated by setting a light source in all points of \reach{k}, and selecting all the lit points.

This process closely resembles the bredth-first search, but a key difference is that the search is done in continuous space rather than in a graph.
A nontrivial part in any minimum link path algorithm is maintaining the illuminated area in a data structure that allows efficient computation of \reach{k+1} from \reach{k}.

Representing the illuminated area can be simplified by first splitting the free space into simple primitives.
A common approach in computational geometry is to start by triangulating the input, which allows working with simple forms.
In case of minimum link paths with restricted orientations, rectangles or trapezoids are the most comfortable representations.
In section~\ref{sec:decomposition} we present algorithms for construction decompositions suitable for minimum link path computation.

With restricted orientations that the paths can take, we can use \emph{sweepline algorithms} to efficiently compute \reach{k+1} from \reach{k}.
The idea is to "sweep" over the search space by a line, and use the sweep to calculate how the path can advance into the direction of the sweep line.
This generic technique allows us to transform the 2-dimensional illumination problem into a series of easier 1-dimensional problems on the sweep line.
The sweepline technique is discussed in section~\ref{sec:sweep}.

During the sweeps we need to maintain the relationship between the sweepline and the obstacles as well as the region \reach{k}.
Maintaining this kind of information requires efficient handling of 1-dimensional intervals.
\emph{Segment tree} is a generic data structure for working with intervals.
It can be used to efficiently implement all the operations required by the staged illumination.
Segment trees are described in section~\ref{sec:segtree}.

We combine the aforementioned concepts into an algorithm for finding minimum link paths in section~\ref{sec:minlink2d}.
The ideas of the two-dimensional solution can also be generalized to work in higher dimensions.
Many details need to be taken care of, but the basic ideas are relatively straightforward to transfer to more than two dimensions.
The space is decomposed into cuboids instead of rectangles, and the sweep line is replaced by a sweep plane.
The segment tree can also be generalized into a higher dimensional structure.
These elements are combined into an algorithm for finding minimum link paths in higher dimensional domains in section~\ref{sec:minlink3d}.


\section{Space decomposition}\label{sec:decomposition}

\subsection{Sweepline algorithms}\label{sec:sweep}

\section{Segment tree}\label{sec:segtree}

\section{Planar minimum link paths}\label{sec:minlink2d}

\section{Paths in 3 and higher dimensions}\label{sec:minlink3d}

\section{Conclusions}\label{sec:conclusions}


\nocite{*}
\bibliographystyle{tktl}
\bibliography{ref}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Model ABC}

\end{document}


