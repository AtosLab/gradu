\documentclass[english,gradu]{tktltiki2018}
\usepackage{epsfig}
%\usepackage[pdftex]{graphicx}
\usepackage{subfigure}
\usepackage{url}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx,mathabx}
\usepackage{subfigure,xspace}
\usepackage{algpseudocode}
\begin{document}
\onehalfspacing

\newtheorem{theo}{Theorem}
\newtheorem{lem}[theo]{Lemma}
\newtheorem{cor}[theo]{Corollary}

\theoremstyle{definition}
%\newtheorem{def}[theo]{Definition}
\newtheorem{prob}{Problem}
\newtheorem{alg}{Algorithm}
\newtheorem{ex}{Example}

\theoremstyle{remark}
\newtheorem*{note}{Remark}

\newcommand\range[2]{\ensuremath{\left [ #1 , #2 \right )}\xspace}
\newcommand\orange[2]{\ensuremath{\left ( #1 , #2 \right )}\xspace}
\newcommand\crange[2]{\ensuremath{\left [ #1 , #2 \right ]}\xspace}
\newcommand\set[1]{\ensuremath{\left\{#1\right\}}\xspace}
\newcommand\size[1]{\ensuremath{\left |#1\right |}\xspace}
\newcommand\ceil[1]{\ensuremath{\left\lceil #1\right\rceil}\xspace}
\newcommand\reals{\ensuremath{\mathbb{R}}\xspace}

\newcommand\spt{\ensuremath{\dot{s}}\xspace}
\newcommand\ept{\ensuremath{\dot{t}}\xspace}
\newcommand\fspace{\ensuremath{\mathcal{A}}\xspace}
\newcommand\dirs{\ensuremath{\mathcal{C}}\xspace}

\newcommand\epts{\ensuremath{P}\xspace}
\newcommand\segsize{\ensuremath{m}\xspace}
\newcommand\inter[1]{\ensuremath{\textsc{interval}(#1)}\xspace}
\newcommand\leftc[1]{\ensuremath{\textsc{left}(#1)}\xspace}
\newcommand\rightc[1]{\ensuremath{\textsc{right}(#1)}\xspace}
\newcommand\reach[1]{\ensuremath{\textsc{light}(#1)}\xspace}
\newcommand\reachd[2]{\ensuremath{\textsc{light}_{#2}(#1)}\xspace}
\newcommand\canon[1]{\ensuremath{\bar{\textsc{c}}(#1)}\xspace}
\newcommand\canonp[1]{\ensuremath{\dot{\textsc{c}}(#1)}\xspace}
\newcommand\canont[2]{\ensuremath{\textsc{c}(#1,#2)}\xspace}
\newcommand\canoni[2]{\ensuremath{\textsc{c}_{#2}(#1)}\xspace}
\newcommand\canonpar[1]{\ensuremath{\textsc{p}_{\textsc{c}}(#1)}\xspace}
\newcommand\epar[1]{\ensuremath{\textsc{p}(#1)}\xspace}
\newcommand\visitp{\ensuremath{\textsc{VisitParent}}\xspace}
\newcommand\visitc{\ensuremath{\textsc{VisitCanonical}}\xspace}

\newcommand\pop[1]{\ensuremath{\textsc{pop}(#1)}\xspace}

\newcommand\y[1]{\ensuremath{{#1}_y}\xspace}
\newcommand\x[1]{\ensuremath{{#1}_x}\xspace}
\newcommand\xrange[1]{\ensuremath{x(#1)}\xspace}
\newcommand\yrange[1]{\ensuremath{y(#1)}\xspace}
\newcommand\zrange[1]{\ensuremath{z(#1)}\xspace}
\newcommand\xranget[2]{\ensuremath{x(#1)_{#2}}\xspace}
\newcommand\yranget[2]{\ensuremath{y(#1)_{#2}}\xspace}
\newcommand\nbs[1]{\ensuremath{\textsc{nbs}{(#1)}}\xspace}
\newcommand\nbsd[2]{\ensuremath{\textsc{nbs}_{#2}{(#1)}}\xspace}

\newcommand\decomp[1]{\ensuremath{\textsc{dec}_{#1}}\xspace}
%\newcommand\decompc[1]{\ensuremath{\textsc{hajo}({#1})}\xspace}
\newcommand\sweep[2]{\ensuremath{\textsc{sweep}_{#2}{(#1)}}\xspace}
\newcommand\stepof[1]{\ensuremath{\textsc{step}{(#1)}}\xspace}
\newcommand\proj[2]{\ensuremath{\text{proj}_{#1}(#2)}\xspace}

\newcommand\rotr[1]{\ensuremath{\top #1}\xspace}
\newcommand\vecof[1]{\ensuremath{\left [#1\right ]}\xspace}
\newcommand\sline[1]{\ensuremath{S_{#1}}\xspace}
\newcommand\intert[2]{\ensuremath{\textsc{interval}_{#1}(#2)}\xspace}
\newcommand\point[1]{\ensuremath{\left ({#1}\right )}\xspace}

\newcommand\cellevt{\ensuremath{\texttt{CellEvent}}\xspace}
\newcommand\obsevt{\ensuremath{\texttt{ObstacleEvent}}\xspace}
\newcommand\addrectevt{\ensuremath{\texttt{AddRectEvent}}\xspace}


\title{Minimum Link Paths In Two and More Dimensions}
\author{Mikko Sysikaski}
\date{\today}
\level{Master's thesis}

% For new study programmes (2017->) to appear on title page
%\department{Master's Programme in Computer Science}
%\department{Master's Programme in Data Science}
%\department{Bachelor's Programme in Computer Science}

\maketitle

\numberofpagesinformation{\numberofpages\ pages + \numberofappendixpages\ appendices}

%\classification{\protect{\ \\
%\  General and reference $\rightarrow$ Document types  $\rightarrow$ Surveys and overviews\  \\
%\  Applied computing  $\rightarrow$ Document management and text processing  $\rightarrow$ Document management $\rightarrow$ Text editing\\
%}}

\keywords{algorithms, computational geometry}

\supervisors{Antti Laaksonen and Jyrki Kivinen}

%default (40 cr thesis)
%\program{Computer Science}

%Computer Science Master's Programme thesis, 30 cr
%\program{Study Programme in Computer Science} 

%Data Science thesis, 30 cr
%\program{Master's Programme in Data Science}

%Bachelor's thesis 
%\level{Bachelor's thesis}
%Computer Science Bachelor's Programme (2017->) thesis
%\program{Bachelor's Programme in Computer Science}

% For CS Master's Programme thesis 2017->
%\additionalinformation{Thesis for the Algorithms study track }
%\additionalinformation{Thesis for the Networking and Services study track}
%\additionalinformation{Thesis for the Software Systems study track}

% For CS Master's thesis if you follow CS degree requirements prior 2017
%\additionalinformation{Thesis for the Algorithmic Bioinformatics subprogramme}
\additionalinformation{Thesis for the Algorithms, Data Analytics and Machine Learning subprogramme}
%\additionalinformation{Thesis for the Networking and Services subprogramme}
%\additionalinformation{Thesis for the Software Systems subprogramme}

%\level{Seminar essay}
%\additionalinformation{Essay for Seminar on ...}

\begin{abstract}
The thesis subject are algorithms for minimum link path computation.
Minimum link path is a geometric path that consists of straight line segments and does a minimal number of turns.
We present new algorithms to several variations of the minimum link path problem.
\end{abstract}

\mytableofcontents




\section{Introduction}

Path finding problems are a widely studied subject in algorithmics.\cite{survey}
A typical task is finding the shortest path between two nodes in a graph.
Geometric version of the problem asks for the shortest path in a continuous space, such as plane with polygonal obstacles.
The typical task is to minimize the Euclidean length of the path, but there are other relevant metrics as well.
For example a robot might move forward fast, but be slow at corners, so a long simple route is sometimes preferable to a shorter but more complex route.

The topic of this thesis is finding geometric path the do minimum amount of turns.
Consider a path consisting of a finite number of straight line segments.
The \emph{link distance} of the path is the number of segments.
A \emph{minimum link path} between two points is a path that minimizes the link distance.

Finding minimum link paths is a well studied algorithmic problem.
The basic idea employed by most known algorithms is a simple extension of bredth-first search:
First find points that have link distance~1 to the starting point, then points with link distance~2, and similarly iterate until the desired endpoint is encountered.
Since the search happens in continuous space, the hard part of the algorithms is defining the appropriate data structures to store and update the discovered area.

In this thesis we focus on variants of the problem where the possible directions of the edges of the path are limited.
In $C$-oriented problem we are given a set $C$ of possible directions that the edges can take.
For the $C$-oriented problem, we present a new algorithm that works in time $O(C^2n\log n)$~\cite{revisited}.
We also study 3D version of the problem for a case where the only allowed directions are the coordinate axes.
For this problem we present a new algorithm that works in time $O(n^2\log^2n)$, which is a significant improvement over the earlier best known result $O(n^{2.5}\log n)$.\cite{restricted}
Finally, we extend the 3D solution to work in $D$-dimensional domains in time $O(n^D\log^Dn)$.

\subsection{Problem description}

The definition of the minimum link path problem is the following.
\begin{prob}\label{prob:path}
We are given a description of free space \fspace and two points $\spt\in\fspace$ and $\ept\in\fspace$.
The task is to find a path from \spt to \ept in \fspace with minimum link distance.
\end{prob}

Typically the algorithms for pathfinding start from one of the points, and search the area until the other point is found.
Often this approach allows us to create a data structure that can be used to efficiently find a path between \spt and any other point.
Thus the same algorithms can be applied to solve a problem where \ept is given only afterwards.

\begin{prob}\label{prob:map}
We are given a description of free space \fspace and a point $\spt\in\fspace$.
Construct a data structure that allows finding the minimum link path between \spt and any given point.
\end{prob}

\subsection{Overview of algorithms}\label{sec:overview}

All the known algorithms for the minimum link path problem use the same basic idea:
The tasks is to find a minimum link path from point \spt to point \ept.
Let \reach{k} be the set of points reachable by at most $k$ links from \spt.
Start by defining $\reach{0}=\set{\spt}$, and iteratively compute \reach{k+1} from \reach{k}.
The iteration continues until we find $k$ such that $\ept\in\reach{k}$.
This iteration is often called \emph{staged illumination}, because the computation of \reach{k+1} can be illustrated by setting a light source in all points of \reach{k}, and selecting all the lit points.

This process closely resembles the bredth-first search, but a key difference is that the search is done in continuous space rather than in a graph.
A nontrivial part in any minimum link path algorithm is maintaining the illuminated area in a data structure that allows efficient computation of \reach{k+1} from \reach{k}.

Representing the illuminated area can be simplified by first splitting the free space into simple primitives.
A common approach in computational geometry is to start by triangulating the input, which allows working with simple forms.
In case of minimum link paths with restricted orientations, rectangles or trapezoids are the most comfortable representations.
In section~\ref{sec:decomposition} we present algorithms for construction decompositions suitable for minimum link path computation.

With restricted orientations that the paths can take, we can use \emph{sweep line algorithms} to efficiently compute \reach{k+1} from \reach{k}.
The idea is to "sweep" over the search space by a line, and use the sweep to calculate how the path can advance into the direction of the sweep line.
This generic technique allows us to transform the 2-dimensional illumination problem into a series of easier 1-dimensional problems on the sweep line.
The sweep line technique is discussed in section~\ref{sec:sweep}.

During the sweeps we need to maintain the relationship between the sweep line and the obstacles as well as the region \reach{k}.
Maintaining this kind of information requires efficient handling of 1-dimensional intervals.
\emph{Segment tree} is a generic data structure for working with intervals.
It can be used to efficiently implement all the operations required by the staged illumination.
Segment trees are described in section~\ref{sec:segtree}.

We combine the aforementioned concepts into an algorithm for finding minimum link paths in section~\ref{sec:minlink2d}.
The ideas of the two-dimensional solution can also be generalized to work in higher dimensions.
Many details need to be taken care of, but the basic ideas are relatively straightforward to transfer to more than two dimensions.
The space is decomposed into cuboids instead of rectangles, and the sweep line is replaced by a sweep plane.
The segment tree can also be generalized into a higher dimensional structure.
These elements are combined into an algorithm for finding minimum link paths in higher dimensional domains in section~\ref{sec:minlink3d}.



\section{Space decomposition}\label{sec:decomposition}

The domain of the minimum link path problem is a polygon with smaller polygons as obstacles.
The input is given as a list of polygons, and each polygon is described by a list of vertices.
This form is inconvenient for path planning algorithms, as many simple operations, such as checking whether we can move from a given point to given direction, require scanning through all the polygons.

In the rectilinear minimum link path problem the obstacle edges are oriented according to the coordinate axis.
This allows us to decomposition the free space into rectangles, which is a convenient form for rectilinear path computation.
For each cell of the decomposition we also construct links to neighboring cells and obstacles.
In other words, the decomposition is a graph with rectangles as vertices and an edge between each pair of adjacent rectangles.
If the total number of edges in all the obstacles is $n$, we can decompose the space into $O(n)$ cells such the total number of links between cells is also $O(n)$.

A similar structure can also be used for computing minimum link paths in 3-dimensional domains.
In 3D rectilinear case each obstacle face is a polygon with axis-aligned edges in 3D space.
In this case the free space can be decomposed into a graph with $O(n^2)$ cuboid as vertices and $O(n^2)$ edges.


\subsection{Sweep line algorithms}\label{sec:sweep}

Sweep line algorithms are a generic technique used for a wide range of computational geometry problems.
The idea is to image a line that crosses over the domain.
As the sweep line progresses, we gradually update the solution to take into account the parts of the domain that the line has crossed.
Conceptually the sweep line moves continuously in space, but in practice we only process a discrete set of \emph{events} where some structural change to the solution happens.


\subsection{Planar decomposition}\label{sec:decomp2d}

A rectilinear domain can be decomposed into rectangles by extending each horizontal obstacle edge in both directions until the sides hit a vertical obstacle edge.
This defines the \emph{horizontal decomposition} of the domain, denoted \decomp{x}.
The vertical decomposition \decomp{y} is defined correspondingly by extending all the vertical edges until they hit a horizontal obstacle.

It is easy to see that each cell of \decomp{x} touches at least one obstacle vertex.
Since each vertex can be touched by at most two rectangles, the size of the decomposition is $O(n)$.
Each pair of touching rectangles also shares a common obstacle corner, so the number of links is also $O(n)$.

\decomp{x} can be constructed with a line sweep algorithm.
We sweep over the domain by a horizontal line moving from $y$ coordinate $-\infty$ (down) to $\infty$ (up).
During the sweep we maintain the cross section (intersection) of the free space \fspace and the sweep line.
The intersection consists of non-overlapping intervals, which we store in a binary search tree.

Each element added to the binary tree is a partially constructed rectangle $a$ with the following fields.
\begin{itemize}
\item Interval $\xrange{a}=\range{\xranget{a}{1}}{\xranget{a}{2}}$.
\item Interval $\yrange{a}=\range{\yranget{a}{1}}{\yranget{a}{2}}$.
\item List of neighbor links $\nbs{a}$.
\end{itemize}

The sweep stops at each horizontal obstacle edge.
When moving from down to up, each edge starts either starts or ends an obstacle.
If the edge starts an obstacle, the $x$-range of the edge is fully contained in one of the intervals in the search tree.
If the edge ends an obstacle, the $x$-range does not intersect any intervals in the tree, but the left and right endpoints may touch some intervals.
In both cases the intervals touching the encountered edge are removed from the search tree, and $O(1)$ new intervals are inserted to maintain the sweep line state.
A more exact description of the algorithm follows below.

\begin{alg}\label{alg:split2d}
Decomposition of \fspace into a group of rectangular cells \decomp{x}.
\begin{algorithmic}
\State $T\gets \text{Empty binary search tree}$.
\State $E\gets\text{All horizontal obstacle edges}$.
\State Sort $E$ by the $y$ coordinates of the edges.
\ForAll{$e\in E$}
	\If{$e$ starts an obstacle}
		\Comment Exactly one interval in $T$ intersects \xrange{e}.
		\State $v\gets\text{Lookup $T$ for interval touching \xrange{e}}$.
		\State Remove $v$ from $T$.
		\State $\yranget{v}{2}\gets\y{e}$.
		\ForAll{$u\gets v\setminus s$}
			\State $\yranget{u}{1}\gets\y{e}$.
			\State Insert $v$ to list $\nbs{u}$.
			\State $a\gets\text{New rectangle}$.
			\State $\xrange{a}\gets u$.
			\State $\yranget{a}{1}\gets\y{e}$.
			\State Insert $a$ to tree $T$.
		\EndFor
	\Else\Comment $e$ starts free space.
		\State $a\gets\text{New rectangle}$
		\State $\xrange{a}\gets\xrange{e}$.
		\State $\yranget{a}{1}\gets\y{e}$.
		\ForAll{$v\in$ lookup $T$ for intervals touching \xrange{e}}
			\State Remove $v$ from $T$.
			\State Insert $v$ to list \nbs{a}.
			\State $\xrange{a}\gets\xrange{a}\cup\xrange{v}$.
		\EndFor
		\State Insert $a$ to $T$.
	\EndIf
\EndFor
\end{algorithmic}
\end{alg}

Let us analyze the complexity of the algorithm.

\begin{lem}Algorithm~\ref{alg:split2d} works in time $O(n\log n)$ and space $O(n)$.\end{lem}
\begin{proof}
The algorithm sorts all the horizontal edges in time $O(n\log n)$, and iterates over them in $O(n)$ steps.
On each step we emit $O(1)$ cells and neighbor links, and perform $O(1)$ operations to the binary search tree.
The search tree is a balanced binary tree, so each operation to it is carried out in time $O(\log n)$.
Thus the total complexity of the algorithm is $O(n\log n)$, and we only need $O(n)$ storage for the edge list and the binary search tree.
\end{proof}


\section{Segment tree}\label{sec:segtree}

\section{Planar minimum link paths}\label{sec:minlink2d}

\section{Paths in 3 and higher dimensions}\label{sec:minlink3d}

\section{Conclusions}\label{sec:conclusions}


\nocite{*}
\bibliographystyle{tktl}
\bibliography{ref}

\lastpage

\appendices

\pagestyle{empty}

%\internalappendix{1}{Model ABC}

\end{document}


